// ////////////////////////////////////////////////////////////////////////////
// ////////////////////////////////////////////////////////////////////////////
//	MLB Utility Library Module File
// ////////////////////////////////////////////////////////////////////////////
/*
	File Name			:	Epis_01.cpp

	File Description	:	Percentiles estimation.

	Revision History	:	2015-10-08 --- Creation.
									Michael L. Brock

	Reference(s)		:	Calculating Percentiles
								Ian Robertson, January 09, 2004
								http://web.stanford.edu/class/archive/anthsci/anthsci192/anthsci192.1064/handouts/calculating%20percentiles.pdf

		Copyright Michael L. Brock 2015 - 2015.
		Distributed under the Boost Software License, Version 1.0.
		(See accompanying file LICENSE_1_0.txt or copy at
		http://www.boost.org/LICENSE_1_0.txt)

*/
// ////////////////////////////////////////////////////////////////////////////


// ////////////////////////////////////////////////////////////////////////////
// ////////////////////////////////////////////////////////////////////////////
//	Required include files...
// ////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
typedef unsigned int ObservationType;
//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
class Epis_00 {
public:
	Epis_00()
		:observations_()
	{
	}

	void AddObservation(ObservationType obs)
	{
		obs_set_.insert(obs);
	}

	std::multiset<ObservationType> obs_set_;
};
//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
struct DatumPoint {
	DatumPoint(ObservationType obs = 0, std::size_t occurrences = 0)
		:value_(value)
		,occurrences_(occurrences)
	{
	}

	bool operator < (const DatumPoint &other) const
	{
		return(value_ < other.value_);
	}

	ObservationType value_;
	unsigned int    occurrences_;
};
//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
typedef std::set<DatumPoint>                DatumPointSet;
typedef DatumPointSet::const_iterator       DatumPointSetIterC;
typedef std::pair<DatumPointSetIterC, bool> DatumPointSetInsResult;
//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
class Epis_01 {
public:
	Epis_01()
		:observations_()
	{
	}

	void AddObservation(ObservationType obs)
	{
		DatumPointSetInsResult ins_result(obs_set_.insert(DatumPoint(obs, 1)));

		if (!ins_result.second)
			const_cast<DatumPoint *>(&(*ins_result.first))->value_ = obs;
	}

	DatumPointSet observations_;
};
//	////////////////////////////////////////////////////////////////////////////

namespace {

//	////////////////////////////////////////////////////////////////////////////
const ObservationType MyTestList[] = { 5, 1, 9, 3, 14, 9, 7 };
const std::size_t     MyTestCount  = sizeof(MyTestList) / sizeof(MyTestList[0]);
//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
void TEST_RunMe()
{
	Epis_00 epis_00;
	Epis_01 epis_01;

	for (std::size_t count_1 = 0; count_1 < MyTestCount; ++count_1) {
		epis_00.AddObservation(MyTestList[count_1]);
		epis_01.AddObservation(MyTestList[count_1]);
	}
}
//	////////////////////////////////////////////////////////////////////////////

} // Anonymous namespace

//	////////////////////////////////////////////////////////////////////////////
int main(int argc, char **argv)
{
	int return_code = EXIT_SUCCESS;

	try {
		if (argc < 2)
			TEST_RunMe();
		else
			RunPopulate(::atoi(argv[1]));
	}
	catch (const std::exception &except) {
		std::cerr << "ERROR: " << except.what() << std::endl;
		return_code = EXIT_FAILURE;
	}

	return(return_code);
}
//	////////////////////////////////////////////////////////////////////////////

