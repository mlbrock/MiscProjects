/*
	New Skill Qualifier Specifications:
	--- ----- --------- ---------------
	Skill All                                <op> <number>
	Skill {[Class] <class-name> | Class Any} <op> <number>
	Skill {[Tree] <tree-name> | Tree Any}    <op> <number>
	Skill [Single] <skill-name>              <op> <number>
	Skill Element[al]] <damage-type>         <op> <number>
*/
/*
	Name Mappings for new armor defense and weapon damage specifications:
	---- -------- --- --- ----- ------- --- ------ ------ ---------------
	Enhanced		---> Enhance
	Defense		---> Def
	Damage		---> Dmg
	Percentage	---> Percent
	Percentage	---> %
	Minimum		---> Min
	Maximum		---> Max
	One Handed	---> OneHanded
	One Handed	---> One-Handed
	One Handed	---> 1Handed
	One Handed	---> 1 Handed
	One Handed	---> 1-Handed
	One Handed	---> OneHand
	One Handed	---> One Hand
	One Handed	---> One-Hand
	One Handed	---> 1Hand
	One Handed	---> 1 Hand
	One Handed	---> 1-Hand
	Two Handed	---> TwoHanded
	Two Handed	---> Two-Handed
	Two Handed	---> 2Handed
	Two Handed	---> 2 Handed
	Two Handed	---> 2-Handed
	Two Handed	---> TwoHand
	Two Handed	---> Two Hand
	Two Handed	---> Two-Hand
	Two Handed	---> 2Hand
	Two Handed	---> 2 Hand
	Two Handed	---> 2-Hand
*/
// ISF_QUAL_NAME_TYPE_STAT_EXTENDED
// ISF_StatExtendedList[]
// ISF_StatExtendedMap[]
/*
	New Armor Defense Specifications:
	--- ----- ------- ---------------
	Enhanced Def[ense] [Percent]           <op> <number> ---> getStat(D2JSP_STAT_ITEM_ARMOR_PERCENT, 0);		// 16
	Def[ense]                              <op> <number> ---> getStat(D2JSP_STAT_ARMORCLASS);						// 31
	Plus Def[ense]                         <op> <number> ---> getStat(D2JSP_STAT_ARMORCLASS, 0);					// 31
	Plus Def[ense] Missile                 <op> <number> ---> getStat(D2JSP_STAT_ARMORCLASS);						// 32
	Plus Def[ense] Hand-to-Hand            <op> <number> ---> getStat(D2JSP_STAT_ARMORCLASS);						// 33
*/
/*
	New Weapon Damage Specifications:
	--- ------ ------ ---------------
	Min[imum] Damage                       <op> <number> ---> getStat(D2JSP_STAT_MINDAMAGE);						// 21
	Min[imum] Damage One[-| ]Hand[ed]      <op> <number> ---> getStat(D2JSP_STAT_MINDAMAGE);						// 21
	Max[imum] Damage                       <op> <number> ---> getStat(D2JSP_STAT_MAXDAMAGE);						// 22
	Max[imum] Damage One[-| ]Hand[ed]      <op> <number> ---> getStat(D2JSP_STAT_MAXDAMAGE);						// 22
	Min[imum] Damage Two[-| ]Hand[ed]      <op> <number> ---> getStat(D2JSP_STAT_SECONDARY_MINDAMAGE);			// 23
	Max[imum] Damage Two[-| ]Hand[ed]      <op> <number> ---> getStat(D2JSP_STAT_SECONDARY_MAXDAMAGE);			// 24
	Plus Min[imum] Damage                  <op> <number> ---> getStat(D2JSP_STAT_MINDAMAGE, 0);					// 21
	Plus Min[imum] Damage One[-| ]Hand[ed] <op> <number> ---> getStat(D2JSP_STAT_MINDAMAGE, 0);					// 21
	Plus Min[imum] Damage Two[-| ]Hand[ed] <op> <number> ---> getStat(D2JSP_STAT_SECONDARY_MINDAMAGE, 0);		// 23
	Plus Max[imum] Damage                  <op> <number> ---> getStat(D2JSP_STAT_MAXDAMAGE, 0);					// 22
	Plus Max[imum] Damage One[-| ]Hand[ed] <op> <number> ---> getStat(D2JSP_STAT_MAXDAMAGE, 0);					// 22
	Plus Max[imum] Damage Two[-| ]Hand[ed] <op> <number> ---> getStat(D2JSP_STAT_SECONDARY_MAXDAMAGE, 0);		// 24
	Enhanced Damage [Percent]              <op> <number> ---> getStat(D2JSP_STAT_ITEM_MINDAMAGE_PERCENT, 0);	// 18
	Enhanced Damage Min[imum] [Percent]    <op> <number> ---> getStat(D2JSP_STAT_ITEM_MINDAMAGE_PERCENT, 0);	// 18
	Enhanced Damage Max[imum] [Percent]    <op> <number> ---> getStat(D2JSP_STAT_ITEM_MAXDAMAGE_PERCENT, 0);	// 17
	---------------------------------
		This sword:
			Cruel Champion Sword of Excellence
			One-Hand Damage: 88 to 183
			Two-Hand Damage: 248 to 282
			Required Dexterity: 103
			Required Strength: 163
			Required Level: 57
			Sword Class - Fast Attack Speed
			+240% Enhanced Damage
			+7 to Minimum Damage
		Reports the stats in the Dumper:
-------------------------------------------------------------------------------
Item Name      : Champion Sword
Item Parent    : PanWcLa_SwoA
Item Owner     : 0
Item Owner Type: 0
Item ID        : 84395684
Item GID       : -875286773
Item Class ID  : 232
Item Act       : 1
Item Area      : undefined (Rogue Encampment)
Item Location  : [5, 0]
Item Type      : 4
Item Mode      : 0 (Item inven stash cube store)
Item Code      : 7b7
Item Flags     : 0x00800010 (Identified|Any)
Item Diff      : undefined
Item FLPFile   : undefined
Item Name      : Champion Sword
Item FName     : Cruel Champion Sword of Excellence
Item ILvl      : 93
Item InvFile   : undefined
Item ItemLoc   : 0
Item Class     : 2
Item ItemType  : 30 (swor)
Item Prefix    : Cruel
Item Suffix    : of Excellence
Item Quality   : 4
Item SInvFile  : undefined
Item UInvFile  : undefined
Item X-Size    : 1
Item Y-Size    : 4
Item Champion Sword Stats:
   STAT      :    17 : Item max damage percent              =                  0 =                240
   STAT      :    18 : Item min damage percent              =                  0 =                240
   STAT      :    21 : Min damage                           =                 88 =                  7
   STAT      :    22 : Max damage                           =                183 =                  0
   STAT      :    23 : Secondary min damage                 =                248 =                  7
   STAT      :    24 : Secondary max damage                 =                282 =                  0
   STAT      :    68 : Attack rate                          =                 10 =                  0
   STAT      :    72 : Durability                           =                 40 =                  0
   STAT      :    73 : Max durability                       =                 40 =                  0
Item Champion Sword Base Stats:
   BASE STAT :     0 : flippyfile                           =             flpbsw
   BASE STAT :     1 : invfile                              =             invbsw
   BASE STAT :     2 : uniqueinvfile                        =            invbswu
   BASE STAT :     3 : setinvfile                           =            invbswu
   BASE STAT :     4 : code                                 =                7b7
   BASE STAT :     5 : normcode                             =                bsw
   BASE STAT :     6 : ubercode                             =                9b9
   BASE STAT :     7 : ultracode                            =                7b7
   BASE STAT :     8 : alternategfx                         =                clm
   BASE STAT :    10 : state                                =              65535
   BASE STAT :    11 : cstate1                              =              65535
   BASE STAT :    12 : cstate2                              =              65535
   BASE STAT :    13 : stat1                                =              65535
   BASE STAT :    14 : stat2                                =              65535
   BASE STAT :    15 : stat3                                =              65535
   BASE STAT :    16 : calc1                                =                 -1
   BASE STAT :    17 : calc2                                =                 -1
   BASE STAT :    18 : calc3                                =                 -1
   BASE STAT :    19 : len                                  =                 -1
   BASE STAT :    22 : spelldesccalc                        =                 -1
   BASE STAT :    24 : wclass                               =                1hs
   BASE STAT :    25 : 2handedwclass                        =                2hs
   BASE STAT :    29 : gamble cost                          =            1576303
   BASE STAT :    30 : speed                                =                -10
   BASE STAT :    31 : bitfield1                            =                  3
   BASE STAT :    32 : cost                                 =              19939
   BASE STAT :    37 : namestr                              =              20237
   BASE STAT :    38 : version                              =                100
   BASE STAT :    41 : rarity                               =                  4
   BASE STAT :    42 : level                                =                 77
   BASE STAT :    43 : mindam                               =                 24
   BASE STAT :    44 : maxdam                               =                 54
   BASE STAT :    47 : 2handmindam                          =                 71
   BASE STAT :    48 : 2handmaxdam                          =                 83
   BASE STAT :    49 : rangeadder                           =                  2
   BASE STAT :    50 : strbonus                             =                100
   BASE STAT :    52 : reqstr                               =                163
   BASE STAT :    53 : reqdex                               =                103
   BASE STAT :    55 : invwidth                             =                  1
   BASE STAT :    56 : invheight                            =                  4
   BASE STAT :    58 : durability                           =                 40
   BASE STAT :    61 : component                            =                  5
   BASE STAT :    68 : 2handed                              =                  1
   BASE STAT :    70 : type                                 =                 30
   BASE STAT :    73 : dropsound                            =                229
   BASE STAT :    74 : usesound                             =                229
   BASE STAT :    75 : dropsfxframe                         =                 12
   BASE STAT :    80 : transtbl                             =                  5
   BASE STAT :    85 : spawnable                            =                  1
   BASE STAT :    87 : durwarning                           =                  7
   BASE STAT :    89 : hasinv                               =                  1
   BASE STAT :    90 : gemsockets                           =                  4
   BASE STAT :    94 : hit class                            =                  4
   BASE STAT :    95 : 1or2handed                           =                  1
   BASE STAT :    97 : levelreq                             =                 57
   BASE STAT :    99 : Transform                            =                  1
   BASE STAT :   100 : InvTrans                             =                  2
   BASE STAT :   103 : Nameable                             =                  1
   BASE STAT :   172 : AkaraMagicLvl                        =                255
   BASE STAT :   173 : GheedMagicLvl                        =                255
   BASE STAT :   174 : CharsiMagicLvl                       =                255
   BASE STAT :   175 : FaraMagicLvl                         =                255
   BASE STAT :   176 : LysanderMagicLvl                     =                255
   BASE STAT :   177 : DrognanMagicLvl                      =                255
   BASE STAT :   179 : AlkorMagicLvl                        =                255
   BASE STAT :   180 : OrmusMagicLvl                        =                255
   BASE STAT :   181 : ElzixMagicLvl                        =                255
   BASE STAT :   182 : AshearaMagicLvl                      =                255
   BASE STAT :   183 : CainMagicLvl                         =                255
   BASE STAT :   184 : HalbuMagicLvl                        =                255
   BASE STAT :   185 : JamellaMagicLvl                      =                255
   BASE STAT :   186 : MalahMagicLvl                        =                255
   BASE STAT :   187 : LarzukMagicLvl                       =                255
   BASE STAT :   188 : DrehyaMagicLvl                       =                255
   BASE STAT :   189 : NightmareUpgrade                     =                xxx
   BASE STAT :   190 : HellUpgrade                          =                xxx
-------------------------------------------------------------------------------
*/
// ////////////////////////////////////////////////////////////////////////////
// ////////////////////////////////////////////////////////////////////////////
// D2Jsp Integrated Scarfing Facility (ISF) Include File
// ////////////////////////////////////////////////////////////////////////////
//
// File Name       : ISF_Core.d2l
//
// File Version    : 01.00.00
//
// File Description: The ISF core include file.
//
// Revison History : 2002-12-16 --- Creation.
//
//	Author          : Michael L. Brock (TheDesertWind)
//
//	Copyright       : (c) 2002 - 2004, Michael L. Brock. All rights reserved.
//
// ////////////////////////////////////////////////////////////////////////////

	// Include guard
if (typeof(D2JSP_INCLUDE_GUARD_ISF_d2l) == "undefined") {
	var D2JSP_INCLUDE_GUARD_ISF_d2l = true;

// ////////////////////////////////////////////////////////////////////////////
// ////////////////////////////////////////////////////////////////////////////
// Required include files...
// ////////////////////////////////////////////////////////////////////////////
include("TDW/_D2JSP_Utility.d2l");

includeonce("TDW/TDW_Cfg.d2l");
includeonce("TDW/TDW_Move.d2l");
includeonce("TDW/TDW_BeltManager.d2l");
includeonce("TDW/_D2JSP_Areas.d2l");
includeonce("TDW/_D2JSP_BaseStats.d2l");
includeonce("TDW/_D2JSP_Items.d2l");
includeonce("TDW/_D2JSP_Objects.d2l");
includeonce("TDW/_D2JSP_Skills.d2l");
includeonce("TDW/_D2JSP_Stats.d2l");
includeonce("TDW/_D2JSP_Common.d2l");
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
// ////////////////////////////////////////////////////////////////////////////
// The ISF version number.
// ////////////////////////////////////////////////////////////////////////////
var ISF_VERSION_NUMBER = "00.00.01";
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
// ////////////////////////////////////////////////////////////////////////////
// USED EXTERNALLY:
// Defines the flags used in ISF parsing and compilation.
// ////////////////////////////////////////////////////////////////////////////
var ISF_PARSE_FLAG_NONE              = 0x00000000;
var ISF_PARSE_FLAG_CONTINUE_ON_ERROR = 0x00000001;
var ISF_PARSE_FLAG_BM_FILE_SAVE      = 0x00001000;
var ISF_PARSE_FLAG_BM_FILE_DETAIL    = 0x00002000;
var ISF_PARSE_FLAG_BM_FILE_XLATES    = 0x00004000;
var ISF_EVAL_FLAG_RETURN_SOURCE_INFO = 0x00010000;
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
// ////////////////////////////////////////////////////////////////////////////
// USED EXTERNALLY:
// Defines the flags used in ISF item pickup.
// ////////////////////////////////////////////////////////////////////////////
var ISF_PICKUP_FLAG_NONE         = 0x00000000;
var ISF_PICKUP_FLAG_ITEM         = 0x00000001;
var ISF_PICKUP_FLAG_BELT_SIMPLE  = 0x00000002;
var ISF_PICKUP_FLAG_BELT_SMART   = 0x00000004;
var ISF_PICKUP_FLAG_GOLD         = 0x00000008;
var ISF_PICKUP_FLAG_CURSOR       = 0x00000010;
var ISF_PICKUP_FLAG_NO_RETURN    = 0x00000020;
var ISF_PICKUP_FLAG_FAST_USE_ANY = 0x00000040;
var ISF_PICKUP_FLAG_ALL          = ISF_PICKUP_FLAG_ITEM       |
											  ISF_PICKUP_FLAG_BELT_SMART |
											  ISF_PICKUP_FLAG_GOLD       |
											  ISF_PICKUP_FLAG_CURSOR     |
											  ISF_PICKUP_FLAG_NO_RETURN;
var ISF_PICKUP_FLAG_DEFAULT      = ISF_PICKUP_FLAG_ITEM;
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
// ////////////////////////////////////////////////////////////////////////////
// USED EXTERNALLY:
// Defines the flags used in ISF chest/casket/urn/et cetera popping.
// ////////////////////////////////////////////////////////////////////////////
var ISF_CHEST_FLAG_NONE    = 0x00000000;
var ISF_CHEST_FLAG_LOCKED  = 0x00000001;
var ISF_CHEST_FLAG_TRAP    = 0x00000002;
var ISF_CHEST_FLAG_SPECIAL = 0x00000004;
var ISF_CHEST_FLAG_ALL     =
	ISF_CHEST_FLAG_LOCKED | ISF_CHEST_FLAG_TRAP | ISF_CHEST_FLAG_SPECIAL;
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
var ISF_CHEST_SpecialChestHash = new Array();
ISF_CHEST_SpecialChestHash["329"] = "mafistochestlargeLeft";	// Durance 3
ISF_CHEST_SpecialChestHash["330"] = "mafistochestlargeright";	// Durance 3
ISF_CHEST_SpecialChestHash["331"] = "mafistochestmedleft";		// Durance 3
ISF_CHEST_SpecialChestHash["332"] = "mafistochestmedright";		// Durance 3
ISF_CHEST_SpecialChestHash["355"] = "horadric scroll chest";	// Act 2 Sewer 3
ISF_CHEST_SpecialChestHash["354"] = "horadric cube chest";		// Halls 3
ISF_CHEST_SpecialChestHash["356"] = "staff of kings chest";		// Maggot 3
ISF_CHEST_SpecialChestHash["397"] = "sparklychest";				// All over
ISF_CHEST_SpecialChestHash["405"] = "khalim chest";				// Act 3 Sewer 2
ISF_CHEST_SpecialChestHash["406"] = "khalim chest";				// Flayer 3
ISF_CHEST_SpecialChestHash["407"] = "khalim chest";				// Spider Cavern
ISF_CHEST_SpecialChestHash["455"] = "specialchest";				// All over
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
// ////////////////////////////////////////////////////////////////////////////
// USED EXTERNALLY:
// Defines the flags used in ISF stashing.
// ////////////////////////////////////////////////////////////////////////////
var ISF_STASH_FLAG_NONE                = 0x00000000;
var ISF_STASH_FLAG_IGNORE_CURSOR_ITEM  = 0x00000001;
var ISF_STASH_FLAG_STASH_NOT_IN_CUBE   = 0x00000002;
var ISF_STASH_FLAG_OTHER_ITEMS         = 0x00000004;
var ISF_STASH_FLAG_EXIT_ON_ID_FAILURE  = 0x00000010;
var ISF_STASH_FLAG_STASH_ON_ID_FAILURE = 0x00000020;
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
// ////////////////////////////////////////////////////////////////////////////
// USED EXTERNALLY:
// Defines the return codes from the stashing logic.
//
// NB: A return of 'ISF_STASH_RETURN_CURSOR_ITEM_LOOP' should be considered
// a fatal error because the stashing code has iteratively tried and failed
// to clear the cursor.
// ////////////////////////////////////////////////////////////////////////////
var ISF_STASH_RETURN_OK                = 0;
var ISF_STASH_RETURN_NOT_TOWN_ERROR    = 1;
var ISF_STASH_RETURN_ID_TOME_ERROR     = 2;
var ISF_STASH_RETURN_CURSOR_ITEM_START = -1;
var ISF_STASH_RETURN_CURSOR_ITEM_LOOP  = -2;
var ISF_STASH_RETURN_STASH_NOT_FOUND   = -3;
var ISF_STASH_RETURN_ITEM_NOT_FOUND    = -4;
var ISF_STASH_RETURN_ID_FAILURE        = -5;
var ISF_STASH_RETURN_MOVE_FAILURE      = -6;
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
// ////////////////////////////////////////////////////////////////////////////
// USED EXTERNALLY:
// Lists the items which could not be picked up the last time that a pickup
// function was called because there was insufficient space in the inventory.
// ////////////////////////////////////////////////////////////////////////////
var ISF_LastPickupNoSpace = new Array();
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
var ISF_CB_TYPE_PICKUP_ITEM            = 0;
var ISF_CB_TYPE_CHEST_POP              = 1;
var ISF_CB_TYPE_DOOR_OPEN              = 2;
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
var ISF_CB_INFO_STAGE_PICKUP_NONE      = 0;
var ISF_CB_INFO_STAGE_PICKUP_START     = 1;
var ISF_CB_INFO_STAGE_PICKUP_BEFORE    = 2;
var ISF_CB_INFO_STAGE_PICKUP_DURING    = 3;
var ISF_CB_INFO_STAGE_PICKUP_AFTER     = 4;
var ISF_CB_INFO_STAGE_PICKUP_END       = 5;
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
function ISF_CB_INFO_PickupData(stage, list, index, item, distance, will_fit)
{
	this.stage    = stage;
	this.list     = list;
	this.index    = index;
	this.item     = item;
	this.distance = distance;
	this.will_fit = will_fit;
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
var ISF_CB_InfoPickup =
	new ISF_CB_INFO_PickupData(ISF_CB_INFO_STAGE_PICKUP_NONE, new Array(), 0,
		null, 0, false);
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
// ////////////////////////////////////////////////////////////////////////////
/*
	THIS IS AN EXTERNALLY AVAILABLE API FUNCTION
*/
// ////////////////////////////////////////////////////////////////////////////
function ISF_IsCfg(isf_cfg)
{
	return(((isf_cfg instanceof ISF_Cfg) || (isf_cfg instanceof ISF_CfgTriple)) ?
		true : false);
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
// ////////////////////////////////////////////////////////////////////////////
/*
	THIS IS AN EXTERNALLY AVAILABLE API FUNCTION

	This function loads an ISF file and compiles it to the ISF internal formal.

	The file may contain include directives in the form:

		include "<file-name>"

	Leading and trailing spaces are not significant, nor is the number of
	spaces between the 'include' string and the quoted string which contains
	the file name to be included. There must be at least one white-space
	character separating the two however.

	Include files need not reside in scripts/libs.
*/
// ////////////////////////////////////////////////////////////////////////////
function ISF_CreateTriple(source_stash, source_sell, in_flags, error_list)
{
	var new_isf_triple = null;
	var isf_text       = new Array();
	var tmp_error_list = new Array();
	var type_stash;
	var type_sell;
	var source_name;
	var isf_cfg_stash;
	var isf_cfg_sell;
	var isf_cfg_merged;

	source_stash = (source_stash != null) ? source_stash :
		TDW_CFG_GetFileSpec("settings/ISF");
	source_sell  = (source_sell != null)  ? source_sell :
		TDW_CFG_GetFileSpec("settings/ISF.SELL");
	error_list   = D2JSP_UTIL_GEN_TypeOfArrayIndexed(error_list) ? error_list :
		(new Array());

	type_stash   = (D2JSP_UTIL_GEN_TypeOfString(source_stash)) ? 0 :
		((D2JSP_UTIL_GEN_TypeOfArrayIndexed(source_stash)) ? 1 : -1);
	type_sell    = (D2JSP_UTIL_GEN_TypeOfString(source_sell)) ? 0 :
		((D2JSP_UTIL_GEN_TypeOfArrayIndexed(source_sell)) ? 1 : -1);

	if (!(isf_cfg_stash = ISF_Create(source_stash, 0, tmp_error_list))) {
		source_name = (!type_stash) ? source_stash :
			((type_stash == 1) ? ISF_INTERNAL_SOURCE_NAME : "*INVALID-SOURCE*");
		while (tmp_error_list.length)
			error_list.push(source_name + ": " + tmp_error_list.shift());
	}

	if (!(isf_cfg_sell = ISF_Create(source_sell, 0, tmp_error_list))) {
		source_name = (!type_sell) ? source_sell :
			((type_sell == 1) ? ISF_INTERNAL_SOURCE_NAME : "*INVALID-SOURCE*");
		while (tmp_error_list.length)
			error_list.push(source_name + ": " + tmp_error_list.shift());
	}

	if (!error_list.length) {
		var line_list;
		if (!type_stash)
			isf_text.push("include \"" + source_stash + "\"");
		else
			isf_text = isf_text.concat(source_stash);
		if (!type_sell)
			isf_text.push("include \"" + source_sell + "\"");
		else
			isf_text = isf_text.concat(source_sell);
		if (!(isf_cfg_merged = ISF_Create(isf_text, 0, tmp_error_list))) {
			while (tmp_error_list.length)
				error_list.push(ISF_INTERNAL_SOURCE_NAME + ": " +
					tmp_error_list.shift());
		}
		else
			new_isf_triple =
				new ISF_CfgTriple(isf_cfg_stash, isf_cfg_sell, isf_cfg_merged);
	}

	if (error_list.length) {
		isf_cfg_stash  = null;
		isf_cfg_sell   = null;
		isf_cfg_merged = null;
	}

	runGC();

	return(new_isf_triple);
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
// ////////////////////////////////////////////////////////////////////////////
/*
	THIS IS AN EXTERNALLY AVAILABLE API FUNCTION

	This function loads an ISF file and compiles it to the ISF internal formal.

	The file may contain include directives in the form:

		include "<file-name>"

	Leading and trailing spaces are not significant, nor is the number of
	spaces between the 'include' string and the quoted string which contains
	the file name to be included. There must be at least one white-space
	character separating the two however.

	Include files need not reside in scripts/libs.
*/
// ////////////////////////////////////////////////////////////////////////////
function ISF_Create(in_source, in_flags, error_list)
{
	var new_isf_cfg = null;
	var isf_cmp     = new Array();

	in_source  = (in_source != null) ? in_source :
		TDW_CFG_GetFileSpec("settings/ISF");
	error_list = D2JSP_UTIL_GEN_TypeOfArrayIndexed(error_list) ? error_list :
		(new Array());

	if (D2JSP_UTIL_GEN_TypeOfString(in_source)) {
		if (!ISF_LoadConfigFromFile(in_source, in_flags, error_list, isf_cmp))
			new_isf_cfg = new ISF_Cfg(isf_cmp);
	}
	else if (D2JSP_UTIL_GEN_TypeOfArrayIndexed(in_source)) {
		if (!ISF_LoadConfigFromList(in_source, in_flags, error_list, isf_cmp))
			new_isf_cfg = new ISF_Cfg(isf_cmp);
	}
	else
		error_list.push("Invalid source parameter: expected either the name of " +
			"an ISF configuration file or an array of strings.");

	return(new_isf_cfg);
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
// ////////////////////////////////////////////////////////////////////////////
/*
	THIS IS AN EXTERNALLY AVAILABLE API FUNCTION

	This function loads an ISF file and compiles it to the ISF internal formal.

	The file may contain include directives in the form:

		include "<file-name>"

	Leading and trailing spaces are not significant, nor is the number of
	spaces between the 'include' string and the quoted string which contains
	the file name to be included. There must be at least one white-space
	character separating the two however.

	Include files need not reside in scripts/libs.

	This function should be invoked as follows:

	var error_list = new Array();			// Important!
	var isf_cfg    = new Array();			// Important!

	if (!ISF_LoadConfigFromFile(file_name, ISF_PARSE_FLAG_NONE,
		error_list, isf_cfg)) {
		// Do whatever...
	}
	else {
		// Report errors...
	}
*/
// ////////////////////////////////////////////////////////////////////////////
function ISF_LoadConfigFromFile(in_source, in_flags, error_list, isf_cfg)
{
	var parse_cfg = new Array();
	var src_list  = new Array();
	var return_code;
	
	in_flags          = (in_flags != null) ? in_flags : ISF_PARSE_FLAG_NONE;
	error_list.length = 0;
	isf_cfg.length    = 0;

	if (!(return_code = ISF_PARSE_ParseFile(in_source, null, in_flags,
		error_list, parse_cfg, src_list)))
{
runGC();
		return_code = ISF_CompileConfig(in_source, in_flags, error_list,
			parse_cfg, isf_cfg, src_list);
}

	return(return_code);
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
// ////////////////////////////////////////////////////////////////////////////
/*
	THIS IS AN EXTERNALLY AVAILABLE API FUNCTION

	This function compiles an array of strings to the ISF internal formal.

	The array may contain include directives in the form:

		include "<file-name>"

	See the description of 'ISF_LoadConfigFromList()' for further details.

	This function should be invoked as follows:

	var error_list = new Array();			// Important!
	var isf_cfg    = new Array();			// Important!

	if (!ISF_LoadConfigFromList(line_array, ISF_PARSE_FLAG_NONE,
		error_list, isf_cfg)) {
		// Do whatever...
	}
	else {
		// Report errors...
	}
*/
// ////////////////////////////////////////////////////////////////////////////
function ISF_LoadConfigFromList(in_list, in_flags, error_list, isf_cfg)
{
	var parse_cfg = new Array();
	var src_list  = new Array();
	var return_code;

	in_flags          = (in_flags != null) ? in_flags : ISF_PARSE_FLAG_NONE;
	error_list.length = 0;
	isf_cfg.length    = 0;

	if (!(return_code = ISF_PARSE_ParseList(ISF_INTERNAL_SOURCE_NAME,
		in_list, null, in_flags, error_list, parse_cfg, src_list)))
{
runGC();
		return_code = ISF_CompileConfig(ISF_INTERNAL_SOURCE_NAME,
			in_flags, error_list, parse_cfg, isf_cfg, src_list);
}

	return(return_code);
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
// ////////////////////////////////////////////////////////////////////////////
/*
	THIS IS AN EXTERNALLY AVAILABLE API FUNCTION

	This function determines whether an item specified as the second parameter
	meets the criteria for pickup as established by an ISF specified as the
	first parameter.

	The ISF must have been previously compiled by way of a call to one of
	'ISF_LoadConfigFromFile()' or 'ISF_LoadConfigFromList()'.

	The third parameter does nothing as of this writing.
*/
// ////////////////////////////////////////////////////////////////////////////
function ISF_EvalItemForPickup(isf_cfg, __PISF_item_obj__, eval_flags)
{
	if ((typeof(__PISF_item_obj__) != "object") ||
		(typeof(__PISF_item_obj__.code) != "string"))
		return((eval_flags & ISF_EVAL_FLAG_RETURN_SOURCE_INFO) ?
			[false, 0] : false);

	if ((__PISF_item_obj__.quality < D2JSP_ITEM_QUALITY_MAGIC) ||
		(__PISF_item_obj__.quality == D2JSP_ITEM_QUALITY_CRAFTED) ||
		__PISF_item_obj__.getFlag(D2JSP_ITEMFLAG_IDENTIFIED))
		return(ISF_EvalItem(ISF_COMPILED_DATA_EVAL, isf_cfg,
			__PISF_item_obj__, eval_flags));
	else
		return(ISF_EvalItem(ISF_COMPILED_DATA_PICKUP, isf_cfg,
			__PISF_item_obj__, eval_flags));
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
// ////////////////////////////////////////////////////////////////////////////
/*
	THIS IS AN EXTERNALLY AVAILABLE API FUNCTION

	This function determines whether an item specified as the second parameter
	meets the criteria for keeping as established by an ISF specified as the
	first parameter.

	The ISF must have been previously compiled by way of a call to one of
	'ISF_LoadConfigFromFile()' or 'ISF_LoadConfigFromList()'.

	The third parameter does nothing as of this writing.
*/
// ////////////////////////////////////////////////////////////////////////////
function ISF_EvalItemForKeep(isf_cfg, __PISF_item_obj__, eval_flags)
{
	return(ISF_EvalItem(ISF_COMPILED_DATA_EVAL, isf_cfg,
		__PISF_item_obj__, eval_flags));
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
// ////////////////////////////////////////////////////////////////////////////
/*
	THIS IS AN EXTERNALLY AVAILABLE API FUNCTION

	This function determines whether an item specified as the second parameter
	needs to be identified in order to meet the criteria for keeping as
	established by an ISF specified as the first parameter.

	The ISF must have been previously compiled by way of a call to one of
	'ISF_LoadConfigFromFile()' or 'ISF_LoadConfigFromList()'.

	The third parameter does nothing as of this writing.
*/
// ////////////////////////////////////////////////////////////////////////////
function ISF_EvalItemForId(isf_cfg, __PISF_item_obj__, eval_flags)
{
	var eval_index = ISF_COMPILED_DATA_PICKUP;
	var return_data;
	var this_code;
	var this_prior;
	var count_1;
	var spec_index;
	var this_spec;

	return_data = (eval_flags & ISF_EVAL_FLAG_RETURN_SOURCE_INFO) ?
			[false, 0] : false;

	if ((typeof(__PISF_item_obj__) != "object") ||
		(typeof(__PISF_item_obj__.code) != "string"))
		return(return_data);

	if ((__PISF_item_obj__.quality < D2JSP_ITEM_QUALITY_MAGIC) ||
		(__PISF_item_obj__.quality == D2JSP_ITEM_QUALITY_CRAFTED) ||
		__PISF_item_obj__.getFlag(D2JSP_ITEMFLAG_IDENTIFIED))
		return(return_data);

	this_code = __PISF_item_obj__.code;

	for (this_prior = 0; this_prior < isf_cfg[eval_index].length; this_prior++) {
		if (typeof(isf_cfg[eval_index][this_prior][this_code]) != "undefined") {
			for (count_1 = 0;
				count_1 < isf_cfg[eval_index][this_prior][this_code].length;
				count_1++) {
				if ((isf_cfg[eval_index][this_prior][this_code][count_1][1] == "")||
					eval(isf_cfg[eval_index][this_prior][this_code][count_1][1])) {
					if (isf_cfg[ISF_COMPILED_DATA_SPEC_LIST][
						isf_cfg[eval_index][this_prior][this_code][count_1][0]].
						known_unided)
						return((eval_flags & ISF_EVAL_FLAG_RETURN_SOURCE_INFO) ?
							[false, 0] : false);
					else if (!return_data[0])
						return_data =
							(eval_flags & ISF_EVAL_FLAG_RETURN_SOURCE_INFO) ?
							[true,
							isf_cfg[eval_index][this_prior][this_code][count_1][0]] :
							true;
				}
			}
		}
	}

	return(return_data);
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
var ISF_PickupBeltNeedsList = new Array();
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
// ////////////////////////////////////////////////////////////////////////////
/*
	THIS IS AN EXTERNALLY AVAILABLE API FUNCTION

	This function creates the list of items to be picked up for the simple belt
	item pickup algorithm.
*/
// ////////////////////////////////////////////////////////////////////////////
function ISF_CreateBeltPickupHash(belt_flags)
{
	var my_belt         = new TDW_BELTMAN_BeltInfo();
	var belt_needs_list = my_belt.getNeededList(belt_flags);

	ISF_PickupBeltNeedsList = new Array();

	for (var this_prop in belt_needs_list)
		ISF_PickupBeltNeedsList[this_prop] = 0;

	var i_belt_list = new Array();

	for (var this_prop in D2JSP_ITEM_BeltCellUpgrades) {
		for (var count_1 = 0; count_1 < 16; count_1++)
			i_belt_list.push([this_prop, null]);
	}

	var o_belt_list = my_belt.getActionList(i_belt_list, belt_flags);

	for (count_1 = 0; count_1 < o_belt_list.length; count_1++) {
		var this_code = o_belt_list[count_1][TDW_BELTMAN_ITEM_OUT_IN_DATA]
			[TDW_BELTMAN_ITEM_IN_CODE];
		ISF_PickupBeltNeedsList[this_code]++;
	}
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
// ////////////////////////////////////////////////////////////////////////////
/*
	THIS IS AN EXTERNALLY AVAILABLE API FUNCTION

	This function manages the pickup of items. potions and gold.
*/
// ////////////////////////////////////////////////////////////////////////////
function ISF_DoPickup(isf_cfg, pickup_flags, pickup_radius, belt_flags,
	min_gold_amount, destination, callback_func, callback_data)
{
	var pickup_list;
	var gold_room;

	if ((pickup_flags & ISF_PICKUP_FLAG_GOLD) && min_gold_amount) {
		gold_room = (me.getStat(D2JSP_STAT_LEVEL) * 10000) -
			me.getStat(D2JSP_STAT_GOLD);
		if (!gold_room)
			min_gold_amount = 0;
	}

	pickup_list = ISF_CreatePickupList(isf_cfg, pickup_flags, pickup_radius,
		belt_flags, min_gold_amount);

	return(ISF_DoPickupBasic(isf_cfg, pickup_list, pickup_flags, destination,
		callback_func, callback_data));
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
// ////////////////////////////////////////////////////////////////////////////
/*
	THIS IS AN EXTERNALLY AVAILABLE API FUNCTION

	This function manages the popping of chests, caskets, and the like.
*/
// ////////////////////////////////////////////////////////////////////////////
function ISF_DoChestPop(max_distance, pop_flags, destination, max_count,
	callback_func, callback_data)
{
	return(ISF_DoChestPopBasic(max_distance, pop_flags, destination, max_count,
		callback_func, callback_data));
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
// ////////////////////////////////////////////////////////////////////////////
/*
	THIS IS AN EXTERNALLY AVAILABLE API FUNCTION

	This function manages the opening of doors.
*/
// ////////////////////////////////////////////////////////////////////////////
function ISF_DoOpenDoors(max_distance, destination, callback_func,
	callback_data)
{
	return(ISF_DoOpenDoorsBasic(max_distance, destination, callback_func,
		callback_data));
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
// ////////////////////////////////////////////////////////////////////////////
/*
	THIS IS AN EXTERNALLY AVAILABLE API FUNCTION

	Note that there are no stash flags implemented as of this release. So the
	'stash_flags' parameter should always be passed as 'ISF_STASH_FLAG_NONE'.
*/
// ////////////////////////////////////////////////////////////////////////////
function ISF_DoStashing(isf_cfg, exclude_list, stash_flags)
{
	var return_code;
	var stash_obj;

	return_code = ISF_DoStashingBasic(isf_cfg, exclude_list, stash_flags)

	if ((stash_obj = getUnit(D2JSP_UTIL_GETUNIT_OBJECT, "Bank")) != null)
		D2JSP_UTIL_GEN_CancelObject(stash_obj);

	return(return_code);
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
// ////////////////////////////////////////////////////////////////////////////
/*
	THIS IS AN EXTERNALLY AVAILABLE API FUNCTION

	Note that there are no stash flags implemented as of this release. So the
	'stash_flags' parameter should always be passed as 'ISF_STASH_FLAG_NONE'.
*/
// ////////////////////////////////////////////////////////////////////////////
function ISF_DoSelling(isf_cfg, exclude_list, stash_flags)
{
	var return_code;
	var stash_obj;

	return_code = ISF_DoSellingBasic(isf_cfg, exclude_list, stash_flags)

	return(return_code);
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
// ////////////////////////////////////////////////////////////////////////////
/*
	THIS IS AN EXTERNALLY AVAILABLE API FUNCTION
*/
// ////////////////////////////////////////////////////////////////////////////
function ISF_EvalLocalItems(isf_cfg)
{
	var isf_flags = ISF_EVAL_FLAG_RETURN_SOURCE_INFO;
	var item_list = new Array();
	var this_obj  = getUnit(D2JSP_UTIL_GETUNIT_ITEM);

	if (this_obj) {
		do {
			var tmp_obj         = new D2JSP_UTIL_GEN_UnitCloneItem(this_obj);
			if ((tmp_obj.quality >= D2JSP_ITEM_QUALITY_MAGIC) &&
				(tmp_obj.quality != D2JSP_ITEM_QUALITY_CRAFTED) &&
				tmp_obj.getFlag(D2JSP_ITEMFLAG_IDENTIFIED))
				tmp_obj._item_flags ^= D2JSP_ITEMFLAG_IDENTIFIED;
			var sispec          = new ISF_SISpec(this_obj);
			sispec._eval_pickup = isf_cfg.evalItemForPickup(tmp_obj, isf_flags);
			sispec._eval_id     = isf_cfg.evalItemForId(tmp_obj, isf_flags);
			sispec._eval_keep   = isf_cfg.evalItemForKeep(this_obj, isf_flags);
			sispec._flag_pickup = (sispec._eval_pickup[0]) ? true : false;
			sispec._flag_id     = (sispec._eval_id[0])     ? true : false;
			sispec._flag_keep   = (sispec._eval_keep[0])  ? true :
				((this_obj.getFlag(D2JSP_ITEMFLAG_IDENTIFIED)) ? false : -1);
			item_list.push(sispec);
		} while (this_obj && this_obj.getNext());
	}

	return(item_list);
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
// ////////////////////////////////////////////////////////////////////////////
/*
	THIS IS AN EXTERNALLY AVAILABLE API FUNCTION
*/
// ////////////////////////////////////////////////////////////////////////////
function ISF_CursorCheckStart(isf_cfg)
{
	var return_code        = 0;
	var keep_flag          = false;
	var id_flag            = false;
	var container_map_list = null;
	var sispec;
	var this_obj;
	var this_code;
	var this_name;
	var this_quality;
	var this_itemclass;
	var this_xsize;
	var this_ysize;
	var tmp_name;
	var item_destination;
	var count_1;
	var count_2;
	var error_text;

	if (!D2JSP_UTIL_GEN_CheckCursor())
		return(0);

	log_obj            = D2JSP_UTIL_LOG_GetALog();
	container_map_list = D2JSP_ITEM_CONT_BuildMapList();
	this_obj           = getUnit(D2JSP_UTIL_GETUNIT_ITEM, null,
									D2JSP_MODE_ITEM_ON_CURSOR);

	if (!this_obj) {
		if (!me.itemoncursor)				// Hmmm... item on cursor vanished!
			return(0);
		error_text = "Have an item on my cursor but I can't seem to " +
			"access it in order to clear it";
		log_obj.logFatal(D2JSP_UTIL_COLOR_RED + error_text);
		runGC();
		delay(3000);
		return(-1);
	}

	this_code      = this_obj.code;
	this_name      = this_obj.name;
	this_quality   = this_obj.quality;
	this_itemclass = this_obj.itemclass;
	this_xsize     = D2JSP_ITEM_GetItemXSize(this_obj);
	this_ysize     = D2JSP_ITEM_GetItemYSize(this_obj);

	if (this_obj.getFlag(D2JSP_ITEMFLAG_IDENTIFIED))
		keep_flag = ISF_EvalItemForKeep(isf_cfg, this_obj);
	else if ((keep_flag = ISF_EvalItemForPickup(isf_cfg, this_obj)) &&
		ISF_EvalItemForId(isf_cfg, this_obj))
		id_flag = true;

	if (keep_flag)
		sispec = new ISF_SISpec(this_obj, id_flag, true, true);

	tmp_name = D2JSP_ITEM_ColorItemFullName(this_obj);
	if (this_obj.getFlag(D2JSP_ITEMFLAG_IDENTIFIED) &&
		((this_obj.quality == D2JSP_ITEM_QUALITY_SET) ||
		(this_obj.quality == D2JSP_ITEM_QUALITY_UNIQUE)))
		tmp_name += "(" + D2JSP_ITEM_ColorItemFixFName(this_obj) + ")";

	log_obj.logWarning(D2JSP_UTIL_COLOR_YELLOW + "Have an item on my cursor (" +
		tmp_name + D2JSP_UTIL_COLOR_YELLOW + ") --- will try to clear it.");

	if (!keep_flag) {
//		D2JSP_UTIL_GEN_CancelObject(this_obj);
		this_obj.cancel();
		if (!D2JSP_UTIL_GEN_CheckCursor(1000, 10)) {
			log_obj.logInfo("Dropped the " + tmp_name + " from the cursor " +
				"to the gound.");
			runGC();
			return(0);
		}
		error_text = "Attempt to drop the " + tmp_name + D2JSP_UTIL_COLOR_RED +
			" from the cursor to the ground failed.";
		log_obj.logFatal(D2JSP_UTIL_COLOR_RED + error_text);
		log_obj.logFatal(D2JSP_UTIL_COLOR_RED +
			"********** THIS IS A FATAL ERROR **********");
		runGC();
		delay(3000);
		return(-1);
	}

	item_destination = D2JSP_ITEM_CONT_ItemMove(this_obj, container_map_list,
		D2JSP_ITEM_CONT_SRC_INVENTORY);
	if (!item_destination) {
		log_obj.logWarning(D2JSP_UTIL_COLOR_YELLOW + "Attempt to move the " +
			tmp_name + D2JSP_UTIL_COLOR_YELLOW +
			" from the cursor to inventory failed.");
		if (D2JSP_AREA_IsTown())
			log_obj.logWarning(D2JSP_UTIL_COLOR_YELLOW + "Will try to move the " +
				tmp_name + D2JSP_UTIL_COLOR_YELLOW + " into another container.");
		else
			log_obj.logWarning(D2JSP_UTIL_COLOR_YELLOW + "Will try the desperate "+
				"measure of attempting to move the " + tmp_name +
				D2JSP_UTIL_COLOR_YELLOW + " into another container.");
		item_destination = D2JSP_ITEM_CONT_ItemMove(this_obj, container_map_list);
		if (!item_destination) {
			error_text = "Attempt to move the " + tmp_name + D2JSP_UTIL_COLOR_RED +
				" from the cursor to any container failed.";
			log_obj.logFatal(D2JSP_UTIL_COLOR_RED + error_text);
			log_obj.logFatal(D2JSP_UTIL_COLOR_RED +
				"********** THIS IS A FATAL ERROR **********");
			runGC();
			delay(3000);
			return(-1);
		}
	}

	sispec.parent_name = new String(me.name);
	sispec.container   = item_destination[0];
	sispec.x           = item_destination[1];
	sispec.y           = item_destination[2];
	sispec.itemloc     = D2JSP_ITEM_CONT_SourceData[sispec.container][1];

	if (!sispec.findItemExpected("just moved from the cursor"))
		return(-1);

	log_obj.logInfo("Stored the " + tmp_name + " from the cursor to " +
		D2JSP_ITEM_CONT_ToName(item_destination[0]) + " at coordinates [" +
		item_destination[1] + ", " + item_destination[2] + "]");

	if (keep_flag && (sispec.container != D2JSP_ITEM_CONT_SRC_INVENTORY))
		ISF_PRIVATE_InstanceList[ISF_GetCursorItemName()].push(sispec);

	runGC();

	return(0);
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
function ISF_IsChestDesirable(obj_unit, chest_flags)
{
	if (ISF_IsChestObject(obj_unit)) {
		if (!D2JSP_UTIL_GetChestStatus(obj_unit))
			return(true);
		else if ((chest_flags & ISF_CHEST_FLAG_SPECIAL) &&
			ISF_IsChestSpecial(obj_unit))
			return(true);
		else if ((D2JSP_UTIL_GetChestStatus(obj_unit) == 128) &&
			(chest_flags & ISF_CHEST_FLAG_LOCKED))
			return(true);
		else if ((D2JSP_UTIL_GetChestStatus(obj_unit) != 128) &&
			(chest_flags & ISF_CHEST_FLAG_TRAP))
			return(true);
	}

	return(false);
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
function ISF_IsChestSpecial(obj_unit)
{
	return((((obj_unit.classid + "") in ISF_CHEST_SpecialChestHash) ||
		((me.area == D2JSP_AREA_DURANCE_OF_HATE_LEVEL_3) &&
		(obj_unit.x == 17513) && (obj_unit.y == 8063))) ? true : false);
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
function ISF_IsChestObject(obj_unit)
{
// CODE NOTE: From NJaguar
//(unit.type == d2_unit_object &&
//	( getBaseStat(4, unit.classid, D2JSP_BASE_OBJECTS_SELECTABLE0) &&
//	!getBaseStat(4, unit.classid, D2JSP_BASE_OBJECTS_ISDOOR) &&
//	getBaseStat(4, unit.classid, D2JSP_BASE_OBJECTS_MONSTEROK) &&
//	(unit.status!=128 || current_keys>0) )))

// CODE NOTE: Old code --- Keep until getBaseStat() is stable.
	return((ISF_IsChestName(obj_unit.name)) ? true : false);

/* CODE NOTE: New code ... have to get NJag to give me his fix.
	return(((obj_unit.type == D2JSP_UTIL_GETUNIT_OBJECT) &&
		D2JSP_UTIL_GetBaseStatObject(obj_unit, D2JSP_BASE_OBJECTS_SELECTABLE0) &&
		(!D2JSP_UTIL_GetBaseStatObject(obj_unit, D2JSP_BASE_OBJECTS_ISDOOR)) &&
		D2JSP_UTIL_GetBaseStatObject(obj_unit, D2JSP_BASE_OBJECTS_MONSTEROK)) ?
		true : false);
*/
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
// CODE NOTE: Old code --- Keep until getBaseStat() is stable.
function ISF_IsChestName(obj_unit_name)
{
	return((obj_unit_name.toLowerCase() in ISF_ChestHash) ? true : false);
}
// ////////////////////////////////////////////////////////////////////////////

// CODE NOTE: Beginning of the internal library section.

// ////////////////////////////////////////////////////////////////////////////
function ISF_GetCursorItemName()
{
	var cursor_list_name;

	cursor_list_name = "ISF_CursorItemList___" + me.realm + "___" +
		me.account + "___" + me.name;

	return(cursor_list_name.replace(/[^A-Za-z0-9_]/ig, "_"));
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
// ////////////////////////////////////////////////////////////////////////////
// Used for storing private per script instance data...
// ////////////////////////////////////////////////////////////////////////////
var ISF_PRIVATE_InstanceList = new Array();
ISF_PRIVATE_InstanceList[ISF_GetCursorItemName()] = new Array();
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
// ////////////////////////////////////////////////////////////////////////////
// Defines the indices into the compiled ISF array.
// ////////////////////////////////////////////////////////////////////////////
var ISF_COMPILED_DATA_VERSION   = 0;
var ISF_COMPILED_DATA_SOURCE    = 1;
var ISF_COMPILED_DATA_DATE      = 2;
var ISF_COMPILED_DATA_CHECKSUM  = 3;
var ISF_COMPILED_DATA_SRC_LIST  = 4;
var ISF_COMPILED_DATA_SPEC_LIST = 5;
var ISF_COMPILED_DATA_PRIORITY  = 6;
var ISF_COMPILED_DATA_PICKUP    = 7;
var ISF_COMPILED_DATA_ID        = 8;
var ISF_COMPILED_DATA_EVAL      = 9;

var ISF_COMPILED_DATA_COUNT     = (ISF_COMPILED_DATA_EVAL + 1);
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
// ////////////////////////////////////////////////////////////////////////////
// The default priority used if none is specified. 2 ^ 32 - 1
// ////////////////////////////////////////////////////////////////////////////
var ISF_SPEC_ITEM_PRIORITY_MAX_ITEM = 0xF0000000;
var ISF_SPEC_ITEM_PRIORITY_BELT     = (ISF_SPEC_ITEM_PRIORITY_MAX_ITEM + 1);
var ISF_SPEC_ITEM_PRIORITY_GOLD     = (ISF_SPEC_ITEM_PRIORITY_BELT + 1);
var ISF_SPEC_ITEM_PRIORITY_MAXIMUM  = 0xFFFFFFFF;
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
// ////////////////////////////////////////////////////////////////////////////
// Used as the source name when parsing and compiling arrays.
// ////////////////////////////////////////////////////////////////////////////
var ISF_INTERNAL_SOURCE_NAME = "*<<<INTERNAL-SOURCE>>>*";
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
// ////////////////////////////////////////////////////////////////////////////
// Defines the various ISF ISpec name types.
// ////////////////////////////////////////////////////////////////////////////
var ISF_ITEM_NAME_TYPE_ITEMNAME     = 0;	// A set or unique name.
var ISF_ITEM_NAME_TYPE_ITEMCODE     = 1;	// Ya got yer basic item code here.
var ISF_ITEM_NAME_TYPE_ITEMTYPE     = 2;	// From the list of itemtypes.
var ISF_ITEM_NAME_TYPE_ITEMCATEGORY = 3;	// From the list of itemtypes.

var ISF_ITEM_NAME_TYPE_MINIMUM   = ISF_ITEM_NAME_TYPE_ITEMNAME;
var ISF_ITEM_NAME_TYPE_MAXIMUM   = ISF_ITEM_NAME_TYPE_ITEMCATEGORY;
var ISF_ITEM_NAME_TYPE_COUNT     = (ISF_ITEM_NAME_TYPE_MAXIMUM + 1);

var ISF_ITEM_NAME_TYPE_NameList  = [
	"name",
	"code",
	"type",
	"category"
];
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
// ////////////////////////////////////////////////////////////////////////////
// Defines the various ISF QSpec name types.
// ////////////////////////////////////////////////////////////////////////////
var ISF_QUAL_NAME_TYPE_NONE          =  0;
var ISF_QUAL_NAME_TYPE_STAT          =  1;	// From X.getStat().
var ISF_QUAL_NAME_TYPE_QUALITY       =  2;	// Low through crafted.
var ISF_QUAL_NAME_TYPE_ITEMCLASS     =  3;	// Norm, execept, elite.
var ISF_QUAL_NAME_TYPE_PREFIX        =  4;	// 'Cruel', et cetera.
var ISF_QUAL_NAME_TYPE_SUFFIX        =  5;	// 'of Swiftness', et cetera.
var ISF_QUAL_NAME_TYPE_ITEMFLAG      =  6;	// From X.getFlag().
var ISF_QUAL_NAME_TYPE_ITEMCODE      =  7;	// From X.code.
var ISF_QUAL_NAME_TYPE_BASENAME      =  8;	// From X.name.
var ISF_QUAL_NAME_TYPE_FULLNAME      =  9;	// From X.fname.
var ISF_QUAL_NAME_TYPE_SKILL_ALL     = 10;	// X.getStat(127).
var ISF_QUAL_NAME_TYPE_SKILL_CLASS   = 11;	// X.getStat([83,84,85,96,87,179,180])
var ISF_QUAL_NAME_TYPE_SKILL_TREE    = 12;	// X.getStat(188, <tree-number>)
var ISF_QUAL_NAME_TYPE_SKILL_SINGLE  = 13;	// X.getStat(107, <skill-number>)
var ISF_QUAL_NAME_TYPE_SKILL_ELEMENT = 14;	// X.getStat(126, <element-number>)
var ISF_QUAL_NAME_TYPE_STAT_EXTENDED = 15;	// From X.getStat(<stat>[, <number>]).

var ISF_QUAL_NAME_TYPE_MINIMUM   = ISF_QUAL_NAME_TYPE_NONE;
var ISF_QUAL_NAME_TYPE_MAXIMUM   = ISF_QUAL_NAME_TYPE_SKILL_ELEMENT;
var ISF_QUAL_NAME_TYPE_COUNT     = (ISF_QUAL_NAME_TYPE_MAXIMUM + 1);

var ISF_QUAL_NAME_TYPE_NameList  = [
	"none",
	"stat",
	"quality",
	"item class",
	"prefix",
	"suffix",
	"item flag",
	"code",
	"base name",
	"full name",
	"skill all",
	"skill class",
	"skill tree",
	"skill single",
	"skill elemental",
	"stat extended"
];

var ISF_QUAL_NAME_TYPE_NameToTypeList = new Array();
ISF_QUAL_NAME_TYPE_NameToTypeList["none"]             = ISF_QUAL_NAME_TYPE_NONE;
ISF_QUAL_NAME_TYPE_NameToTypeList["stat"]             = ISF_QUAL_NAME_TYPE_STAT;
ISF_QUAL_NAME_TYPE_NameToTypeList["quality"]          = ISF_QUAL_NAME_TYPE_QUALITY;
ISF_QUAL_NAME_TYPE_NameToTypeList["qual"]             = ISF_QUAL_NAME_TYPE_QUALITY;
ISF_QUAL_NAME_TYPE_NameToTypeList["itemclass"]        = ISF_QUAL_NAME_TYPE_ITEMCLASS;
ISF_QUAL_NAME_TYPE_NameToTypeList["item class"]       = ISF_QUAL_NAME_TYPE_ITEMCLASS;
ISF_QUAL_NAME_TYPE_NameToTypeList["class"]            = ISF_QUAL_NAME_TYPE_ITEMCLASS;
ISF_QUAL_NAME_TYPE_NameToTypeList["prefix"]           = ISF_QUAL_NAME_TYPE_PREFIX;
ISF_QUAL_NAME_TYPE_NameToTypeList["suffix"]           = ISF_QUAL_NAME_TYPE_SUFFIX;
ISF_QUAL_NAME_TYPE_NameToTypeList["itemflag"]         = ISF_QUAL_NAME_TYPE_ITEMFLAG;
ISF_QUAL_NAME_TYPE_NameToTypeList["item flag"]        = ISF_QUAL_NAME_TYPE_ITEMFLAG;
ISF_QUAL_NAME_TYPE_NameToTypeList["flag"]             = ISF_QUAL_NAME_TYPE_ITEMFLAG;
ISF_QUAL_NAME_TYPE_NameToTypeList["itemcode"]         = ISF_QUAL_NAME_TYPE_ITEMCODE;
ISF_QUAL_NAME_TYPE_NameToTypeList["item code"]        = ISF_QUAL_NAME_TYPE_ITEMCODE;
ISF_QUAL_NAME_TYPE_NameToTypeList["code"]             = ISF_QUAL_NAME_TYPE_ITEMCODE;
ISF_QUAL_NAME_TYPE_NameToTypeList["basename"]         = ISF_QUAL_NAME_TYPE_BASENAME;
ISF_QUAL_NAME_TYPE_NameToTypeList["base name"]        = ISF_QUAL_NAME_TYPE_BASENAME;
ISF_QUAL_NAME_TYPE_NameToTypeList["name"]             = ISF_QUAL_NAME_TYPE_BASENAME;
ISF_QUAL_NAME_TYPE_NameToTypeList["fullname"]         = ISF_QUAL_NAME_TYPE_FULLNAME;
ISF_QUAL_NAME_TYPE_NameToTypeList["full name"]        = ISF_QUAL_NAME_TYPE_FULLNAME;
ISF_QUAL_NAME_TYPE_NameToTypeList["fname"]            = ISF_QUAL_NAME_TYPE_FULLNAME;
ISF_QUAL_NAME_TYPE_NameToTypeList["skill all"]        = ISF_QUAL_NAME_TYPE_SKILL_ALL;
ISF_QUAL_NAME_TYPE_NameToTypeList["skill class"]      = ISF_QUAL_NAME_TYPE_SKILL_CLASS;
ISF_QUAL_NAME_TYPE_NameToTypeList["skill tree"]       = ISF_QUAL_NAME_TYPE_SKILL_TREE;
ISF_QUAL_NAME_TYPE_NameToTypeList["skill single"]     = ISF_QUAL_NAME_TYPE_SKILL_SINGLE;
ISF_QUAL_NAME_TYPE_NameToTypeList["skill elemental"]  = ISF_QUAL_NAME_TYPE_SKILL_ELEMENT;
ISF_QUAL_NAME_TYPE_NameToTypeList["skill element"]    = ISF_QUAL_NAME_TYPE_SKILL_ELEMENT;
ISF_QUAL_NAME_TYPE_NameToTypeList["stat extended"]    = ISF_QUAL_NAME_TYPE_STAT_EXTENDED;
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
// ////////////////////////////////////////////////////////////////////////////
// Defines the various of ISF QSpec value types.
// ////////////////////////////////////////////////////////////////////////////
var ISF_QUAL_VALUE_TYPE_NONE      = 0;	// None
var ISF_QUAL_VALUE_TYPE_NUMBER    = 1;	// Number
var ISF_QUAL_VALUE_TYPE_STRING    = 2;	// String
var ISF_QUAL_VALUE_TYPE_BOOLEAN   = 3;	// Boolean

var ISF_QUAL_VALUE_TYPE_MINIMUM   = ISF_QUAL_VALUE_TYPE_NONE;
var ISF_QUAL_VALUE_TYPE_MAXIMUM   = ISF_QUAL_VALUE_TYPE_BOOLEAN;
var ISF_QUAL_VALUE_TYPE_COUNT     = (ISF_QUAL_VALUE_TYPE_MAXIMUM + 1);

var ISF_QUAL_VALUE_TYPE_NameList  = [
	"basename",
	"string",
	"boolean"
];
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
// ////////////////////////////////////////////////////////////////////////////
// Maps configuration comparison operators to the JavaScript equivalents.
// ////////////////////////////////////////////////////////////////////////////
var ISF_QUAL_OP_MapToJSList = new Array();
ISF_QUAL_OP_MapToJSList["="] = "==";
ISF_QUAL_OP_MapToJSList["!"] = "!=";
ISF_QUAL_OP_MapToJSList["<"] = "<=";
ISF_QUAL_OP_MapToJSList[">"] = ">=";
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
var ISF_STASH_ACTION_CTL_ISF_CFG     = 0;
var ISF_STASH_ACTION_CTL_FLAGS       = 1;
var ISF_STASH_ACTION_CTL_EXCLUDE     = 2;
var ISF_STASH_ACTION_CTL_MAP_LIST    = 3;
var ISF_STASH_ACTION_CTL_OUTPUT      = 4;
// ////////////////////////////////////////////////////////////////////////////

/*
	CODE NOTE: To be removed.
// ////////////////////////////////////////////////////////////////////////////
var ISF_STASH_ACTION_ELE_CODE        = 0;
var ISF_STASH_ACTION_ELE_CON_LOC     = 1;
var ISF_STASH_ACTION_ELE_X           = 2;
var ISF_STASH_ACTION_ELE_Y           = 3;
var ISF_STASH_ACTION_ELE_XSIZE       = 4;
var ISF_STASH_ACTION_ELE_YSIZE       = 5;
var ISF_STASH_ACTION_ELE_ID_FLAG     = 6;
var ISF_STASH_ACTION_ELE_CURSOR_ITEM = 7;
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
var ISF_CURSOR_ACTION_CODE            = 0;
var ISF_CURSOR_ACTION_NAME            = 1;
var ISF_CURSOR_ACTION_QUALITY         = 2;
var ISF_CURSOR_ACTION_ITEMCLASS       = 3;
var ISF_CURSOR_ACTION_CON_LOC         = 4;
var ISF_CURSOR_ACTION_X               = 5;
var ISF_CURSOR_ACTION_Y               = 6;
var ISF_CURSOR_ACTION_STASH_ACTION    = 7;
// ////////////////////////////////////////////////////////////////////////////
*/

// ////////////////////////////////////////////////////////////////////////////
var ISF_ChestList = [
	"HoleAnim",
	"Casket",
	"ArmorStand",
	"Basket",
	"BoneChest",
	"Chest3",
	"ChestL",
	"ChestSL",
	"ChestSR",
	"CorpseOnStick",
	"GuardCorpse",
	"HungSkeleton",
	"LargeUrn",
	"Obelisk",
	"RockPIle",
	"RogueCorpse",
	"Sarcophagus",
	"TrappedSoul",
	"WeaponRack",
	"animated skulland rockpile",
	"barrel wilderness",
	"barrel wilderness",
	"barrel",
	"basket",
	"bed",
	"body",
	"body",
	"bookshelf",
	"burialchestL",
	"burialchestR",
//	"burningbodies",
//"burningpit",
	"casket",
	"casket",
	"chest",
	"chestR",
	"cocoon",
	"coffin",
	"corpse",
	"corpse",
	"crate",
	"dead body",
	"dead guard",
	"deadbarbarian",
	"deadperson",
	"deadperson2",
	"earmorstandL",
	"earmorstandR",
	"eunuch",
	"eweaponrackL",
	"eweaponrackR",
	"fissure",
	"flag wilderness",
	"goo pile",
	"groundtomb",
	"groundtombL",
	"hidden stash",
	"hidden stash",
	"hiddenstash",
	"hiding spot",
	"hollow log",
	"icecavejar1",
	"icecavejar2",
	"icecavejar3",
	"icecavejar4",
	"jar1",
	"jar2",
	"jar3",
	"jug",
	"loose boulder",
	"loose rock",
//	"pileofskullsandrocks",	// No mode 1 animation causes crash
	"pillar",
//	"pole",
	"ratnest",
	"sarcophagus",
	"skeleton",
	"skull pile",
	"skullpile",
	"stash",
//	"swingingheads",
	"tomb",
	"tomb1",
	"tomb2",
	"tomb3",
	"Urn",
	"urn",
	"woodchest2L",
	"woodchest2R",
	"woodchestL",
	"woodchestL",
	"woodchestR",
	"woodchestR"
];
var ISF_ChestHash = new Array();
for (var count_1 = 0; count_1 < ISF_ChestList.length; count_1++)
	ISF_ChestHash[ISF_ChestList[count_1].toLowerCase()] = 1;
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
var ISF_DoItemIdDelayBase  =  250;
var ISF_DoItemIdDelayMax   = 1000;
var ISF_DoItemIdDelayDelta =   50;

var ISF_DoItemIdDelay      = ISF_DoItemIdDelayBase;
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
// ////////////////////////////////////////////////////////////////////////////
// The ISF_SISpec object contains the data describing an item to be stashed or
// sold and methods for managing that operation.
// ////////////////////////////////////////////////////////////////////////////
// The ISF_SISpec constructor
function ISF_SISpec(in_obj, id_flag, cursor_item_flag, isf_item_flag, other)
{
	var in_parent;

	in_parent             = in_obj.getParent();
//	this.code             = new String(in_obj.code);
	this.code             = in_obj.code;
	this.parent_name      = (in_parent) ?
		D2JSP_UTIL_GEN_CloneObject(in_parent.name) : "";
	this.container        = D2JSP_ITEM_CONT_ItemContainer(in_obj);
	this.itemloc          = D2JSP_UTIL_GEN_CloneObject(in_obj.itemloc);
	this.x                = D2JSP_UTIL_GEN_CloneObject(in_obj.x);
	this.y                = D2JSP_UTIL_GEN_CloneObject(in_obj.y);
	this.xsize            = D2JSP_ITEM_GetItemXSize(in_obj);
	this.ysize            = D2JSP_ITEM_GetItemYSize(in_obj);
	this.quality          = D2JSP_UTIL_GEN_CloneObject(in_obj.quality);
	this.itemclass        = D2JSP_ITEM_GetItemClass(in_obj);
	this.mode             = D2JSP_UTIL_GEN_CloneObject(in_obj.mode);
	this.is_identified    = (in_obj.getFlag(D2JSP_ITEMFLAG_IDENTIFIED)) ?
										true : false;
	this.is_in_socket     = (in_obj.mode == D2JSP_MODE_ITEM_SOCKETED_IN_ITEM) ?
										true : false;
	this.id_flag          = (id_flag) ? true : false;
	this.cursor_item_flag = (cursor_item_flag) ? true : false;
	this.isf_item_flag    = (isf_item_flag) ? true : false;
	this.other            = D2JSP_UTIL_GEN_CloneObject(other);

	this.fullNameColor    = D2JSP_ITEM_ColorItemFullName(in_obj);
	this.fixedFName       = D2JSP_ITEM_FixFName(in_obj);
	this.find_key         = this.code + "|" + this.itemloc + "|" +
		this.original_x + "|" + this.original_y + "|" + this.quality + "|" +
		this.itemclass;
	this.unique_key       = ((in_parent) ? in_parent.name : "NO_PARENT") +
		"|" + this.find_key;

	this.findItem         = ISF_SISpec_findItem;
	this.findItemExpected = ISF_SISpec_findItemExpected;
	this.findItemBasic    = ISF_SISpec_findItemBasic;
	this.waitForMovement  = ISF_SISpec_waitForMovement;
	this.toDelaySpec      = ISF_SISpec_toDelaySpec;
	this.toString         = ISF_SISpec_toString;

/*
if (!D2JSP_ITEM_CONT_IsValid(this.container)) {
	print("*** INVALID ITEM CONTAINER FOR " + this.fullNameColor +
		" --- itemloc = " + in_obj.itemloc + " [" + this + "]");
print("Stopping in container check"); stop();
}
*/
}
//-----------------------------------------------------------------------------
// The basic functionality to locate a stash target object using the ISF_SISpec.
function ISF_SISpec_findItemBasic(itemloc)
{
	var this_obj;
	var this_parent;

	itemloc  = (itemloc != null) ? itemloc : this.itemloc;

	this_obj = getUnit(D2JSP_UTIL_GETUNIT_ITEM, this.code);

	if (this_obj) {
		do {
			this_parent = this_obj.getParent();
			if (this_parent &&
				(this_parent.name.toLowerCase() == this.parent_name.toLowerCase())&&
				(this_obj.itemloc == itemloc) &&
				(this_obj.code == this.code) &&
				(this_obj.quality == this.quality) &&
				(this_obj.x == this.x) &&
				(this_obj.y == this.y))
				return(this_obj);
		} while (this_obj && this_obj.getNext(this.code));
	}

	return(null);
}
//-----------------------------------------------------------------------------
// Iterative functionality to locate a stash target object using the ISF_SISpec.
function ISF_SISpec_findItem(iter_count, iter_time)
{
	var this_obj;
	var count_1;

	iter_count = (iter_count > 0) ? iter_count : 100;
	iter_time  = (iter_time > 0) ? iter_time : 10;

	for (count_1 = 0; count_1 < iter_count; count_1++) {
		if ((this_obj = this.findItemBasic(this.itemloc)) != null)
			return(this_obj);
		delay(iter_time);
	}

	return(null);
}
//-----------------------------------------------------------------------------
// Iterative functionality to locate a stash target object using the ISF_SISpec.
// Displays a log error if not found.
function ISF_SISpec_findItemExpected(stash_phase_text, iter_count, iter_time)
{
	var this_obj = this.findItem(iter_count, iter_time);

	if (!this_obj)
		D2JSP_UTIL_LOG_GetALog().logError("Unable to locate the " +
			this.fullNameColor + " " + stash_phase_text + " in the " +
			D2JSP_ITEM_CONT_ToName(this.container) + " at coordinates [" +
			this.x + ", " + this.y + "].");

	return(this_obj);
}
//-----------------------------------------------------------------------------
// Iterative functionality to determine when an object to be moved departs its
// current location.
function ISF_SISpec_waitForMovement(itemloc, iter_count, iter_time)
{
	var end_time;

	itemloc    = (itemloc != null) ? itemloc : this.itemloc;
	iter_count = (iter_count > 0) ? iter_count : 100;
	iter_time  = (iter_time > 0) ? iter_time : 10;

	end_time   = (new Date()).valueOf() + (iter_count * iter_time);

	while ((new Date()).valueOf() < end_time) {
		if (!this.findItemBasic(itemloc))
			return(true);
		delay(iter_time);
	}

	return(false);
}
//-----------------------------------------------------------------------------
function ISF_SISpec_toDelaySpec()
{
	return(this.code + "\t" + this.x + "\t" + this.y + "\t" + this.quality +
		"\t" + this.itemclass);
}
//-----------------------------------------------------------------------------
// Used only in debugging this code.
function ISF_SISpec_toString()
{
	return([this.code, this.fixedFName, this.itemloc, this.container,
		this.x, this.y, this.xsize, this.ysize, this.mode, this.quality,
		this.itemclass, this.id_flag, this.cursor_item_flag, this.isf_item_flag] +
		"");
}
//-----------------------------------------------------------------------------
function ISF_SISpec_isEqual(item_1, item_2)
{
/*
	return(((item_1.code == item_2.code) && (item_1.itemloc == item_2.itemloc) &&
		(item_1.x == item_2.x) && (item_1.y == item_2.y) &&
		(item_1.xsize == item_2.xsize) && (item_1.ysize == item_2.ysize) &&
		(item_1.quality == item_2.quality) &&
		(item_1.itemclass == item_2.itemclass)) ? true : false);
*/
//	ADF NOTE: The itemclass member is not compared because it doesn't work for
//	rings or amulets...
	return(((item_1.code == item_2.code) && (item_1.itemloc == item_2.itemloc) &&
		(item_1.x == item_2.x) && (item_1.y == item_2.y) &&
		(item_1.xsize == item_2.xsize) && (item_1.ysize == item_2.ysize) &&
		(item_1.quality == item_2.quality)) ? true : false);
}
// ////////////////////////////////////////////////////////////////////////////

var ISF_STASH_VAR_ID_MAX_TRY = 20;

// ////////////////////////////////////////////////////////////////////////////
function ISF_DoStashingBasic(isf_cfg, exclude_list, stash_flags)
{
	var log_obj;
	var stash_list;

	log_obj = D2JSP_UTIL_LOG_GetALog();

	//	///////////////////////////////////////////////////////////////////////
	//	///////////////////////////////////////////////////////////////////////
	// Check to ensure there's nothing on the cursor... If there is, the
	// logic tries to move it so that it can proceed.
	//	///////////////////////////////////////////////////////////////////////
	if (ISF_CursorCheckStart(isf_cfg)) {
		log_obj.logFatal("Unable to perform stashing while there is an item " +
			"on the cursor.");
		return(ISF_STASH_RETURN_CURSOR_ITEM_START);
	}
	//	///////////////////////////////////////////////////////////////////////

	//	///////////////////////////////////////////////////////////////////////
	//	///////////////////////////////////////////////////////////////////////
	// Have to be in town to stash...
	//	///////////////////////////////////////////////////////////////////////
	if (!D2JSP_AREA_IsTown()) {
		log_obj.logError("Unable to perform stashing while not in town " +
			"(currently in " + D2JSP_AREA_AreaToName() + ").");
		return(ISF_STASH_RETURN_NOT_TOWN_ERROR);
	}
	//	///////////////////////////////////////////////////////////////////////

	//	///////////////////////////////////////////////////////////////////////
	//	///////////////////////////////////////////////////////////////////////
	// Get the list of items to stash...
	//	///////////////////////////////////////////////////////////////////////
	stash_list = ISF_GetStashActionList(isf_cfg, stash_flags, exclude_list);
	//	///////////////////////////////////////////////////////////////////////

	var return_code = ISF_DoStashingInternal(isf_cfg, stash_list, stash_flags);

	var stash_obj;
	if ((stash_obj = getUnit(D2JSP_UTIL_GETUNIT_OBJECT, "Bank")) != null)
		D2JSP_UTIL_GEN_CancelObject(stash_obj);

	return(return_code);
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
function ISF_DoStashingInternal(isf_cfg, stash_list, stash_flags)
{
	var return_code = ISF_STASH_RETURN_OK;
	var id_count    = 0;
	var id_delay    = 250;
	var container_map_list;
	var log_obj;
	var sispec;
	var stash_obj;
	var count_1;
	var count_2;
	var count_3;
	var results_data;
	var isc_count;
	var ibk_obj;
	var this_obj;
	var item_name;
	var id_text;

	log_obj = D2JSP_UTIL_LOG_GetALog();

	ISF_DoItemIdDelay = ISF_DoItemIdDelayBase;

	//	///////////////////////////////////////////////////////////////////////
	//	///////////////////////////////////////////////////////////////////////
	// Check to ensure there's nothing on the cursor... If there is, the
	// logic tries to move it so that it can proceed.
	//	///////////////////////////////////////////////////////////////////////
	if (ISF_CursorCheckStart(isf_cfg)) {
		log_obj.logFatal("Unable to perform stashing while there is an item " +
			"on the cursor.");
		return(ISF_STASH_RETURN_CURSOR_ITEM_START);
	}
	//	///////////////////////////////////////////////////////////////////////

	//	///////////////////////////////////////////////////////////////////////
	//	///////////////////////////////////////////////////////////////////////
	// Have to be in town to stash...
	//	///////////////////////////////////////////////////////////////////////
	if (!D2JSP_AREA_IsTown()) {
		log_obj.logError("Unable to perform stashing while not in town " +
			"(currently in " + D2JSP_AREA_AreaToName() + ").");
		return(ISF_STASH_RETURN_NOT_TOWN_ERROR);
	}
	//	///////////////////////////////////////////////////////////////////////

	//	///////////////////////////////////////////////////////////////////////
	//	///////////////////////////////////////////////////////////////////////
	// If an empty list, we're basically done. But check gold for stashing...
	//	///////////////////////////////////////////////////////////////////////
	if ((!stash_list.length) && D2JSP_ITEM_ShouldMoveExcessGoldToStash()) {
		D2JSP_COMM_ExcessGoldToStash();
		return(ISF_STASH_RETURN_OK);
	}
	//	///////////////////////////////////////////////////////////////////////

	//	///////////////////////////////////////////////////////////////////////
	//	///////////////////////////////////////////////////////////////////////
	// Count the number of items for stashing which need to be identified...
	//	///////////////////////////////////////////////////////////////////////
	for (count_1 = 0; count_1 < stash_list.length; count_1++)
		id_count += (stash_list[count_1].id_flag) ? 1 : 0;
	//	///////////////////////////////////////////////////////////////////////

	log_obj.logInfo("There " + ((stash_list.length != 1) ? "are " : "is ") +
		stash_list.length + " item" + ((stash_list.length != 1) ? "s" : "") +
		" pending a stashing action, of which " + id_count + " need" +
		((id_count != 1) ? "" : "s") + " to be identified.");

	//	///////////////////////////////////////////////////////////////////////
	//	///////////////////////////////////////////////////////////////////////
	// Ensure we have a Tome of Identify ready...
	//	///////////////////////////////////////////////////////////////////////
	if (id_count) {
		ibk_obj = D2JSP_COMM_GetALocalTome("ibk");
		if (ibk_obj) {
			isc_count = ibk_obj.getStat(D2JSP_STAT_QUANTITY);
			if (isc_count < Math.min(id_count, 20)) {
				if (D2JSP_NPC_FillIBK()) {
					log_obj.logError("Was unable to re-fill an ID tome");
					return(ISF_STASH_RETURN_ID_TOME_ERROR);
				}
				else
					D2JSP_NPC_FillTomesAll();
			}
		}
		else if (D2JSP_NPC_PurchaseIBK()) {
			log_obj.logError("Was unable to purchase an ID tome");
			return(ISF_STASH_RETURN_ID_TOME_ERROR);
		}
		ibk_obj = D2JSP_COMM_GetALocalTome("ibk");
		if (ibk_obj)
			isc_count = ibk_obj.getStat(D2JSP_STAT_QUANTITY);
		else {
			log_obj.logError("Just arranged to have an ID tome on hand, but it " +
				"seems to have vanished!");
			return(ISF_STASH_RETURN_ID_TOME_ERROR);
		}
	}
	//	///////////////////////////////////////////////////////////////////////

	//	///////////////////////////////////////////////////////////////////////
	//	///////////////////////////////////////////////////////////////////////
	// Go to the stash as some items to be identified might be within...
	// ... Put any excess gold inside now.
	//	///////////////////////////////////////////////////////////////////////
	if (D2JSP_ITEM_CanMoveExcessGoldToStash())
		D2JSP_COMM_ExcessGoldToStash();
	if ((stash_obj = D2JSP_COMM_InteractWithStash()) == null) {
		log_obj.logError("Unable to locate the stash.");
		return(ISF_STASH_RETURN_STASH_NOT_FOUND);
	}
	//	///////////////////////////////////////////////////////////////////////

	for (count_1 = 0; count_1 < stash_list.length; count_1++) {
		id_delay           = (id_delay > 1000) ? 1000 : id_delay;
		sispec             = stash_list[count_1];
		container_map_list = D2JSP_ITEM_CONT_BuildMapList();
/*
		//	/////////////////////////////////////////////////////////////////
		//	/////////////////////////////////////////////////////////////////
		// With many items to be identified, we can run out of scrolls
		// partway through the stashing process... So fix it...
		//	/////////////////////////////////////////////////////////////////
		if (sispec.id_flag) {
			ibk_obj = D2JSP_COMM_GetALocalTome("ibk");
			if (ibk_obj)
				isc_count = ibk_obj.getStat(D2JSP_STAT_QUANTITY);
			else {
				log_obj.logError("Just arranged to have an ID tome on hand, but " +
					"it seems to have vanished!");
				return(ISF_STASH_RETURN_ID_TOME_ERROR);
			}
			if (!isc_count) {
				if ((stash_obj = D2JSP_COMM_InteractWithStash()) == null) {
					log_obj.logError("Unable to locate the stash.");
					return(ISF_STASH_RETURN_STASH_NOT_FOUND);
				}
				D2JSP_UTIL_GEN_CancelObject(stash_obj);
				D2JSP_UTIL_GEN_FuzzyDelay(250);
				if (D2JSP_NPC_FillIBK()) {
					log_obj.logError("Was unable to re-fill an ID tome");
					return(ISF_STASH_RETURN_ID_TOME_ERROR);
				}
				D2JSP_NPC_FillTomesAll();
				isc_count = 20;
				if ((stash_obj = D2JSP_COMM_InteractWithStash()) == null) {
					log_obj.logError("Unable to locate the stash.");
					return(ISF_STASH_RETURN_STASH_NOT_FOUND);
				}
			}
			ibk_obj = D2JSP_COMM_GetALocalTome("ibk");
			if (!ibk_obj) {
				log_obj.logError("Unable to locate the ID tome scroll I just " +
					"determined was available!");
				return(ISF_STASH_RETURN_ID_TOME_ERROR);
			}
		}
*/
		//	/////////////////////////////////////////////////////////////////
		//	/////////////////////////////////////////////////////////////////
		// Get the item we determined needed stashing...
		//
		// If not found, I continue with the other items. The reason it's not
		// a fatal error is that the user may have interactively moved the
		// item out of inventory. Or identified it. Or something.
		//	/////////////////////////////////////////////////////////////////
		if (!(this_obj = sispec.findItemExpected("found previously"))) {
			if (sispec.id_flag)
				id_count--;
			continue;
		}
		//	/////////////////////////////////////////////////////////////////
		item_name = D2JSP_ITEM_ColorItemFullName(this_obj);
		runGC();
		if (sispec.id_flag) {
/*
			//	///////////////////////////////////////////////////////////
			//	///////////////////////////////////////////////////////////
			// Identify this item...
			//	///////////////////////////////////////////////////////////
			log_obj.logDetail("Beginning identification attempt for " +
				item_name + " at location [" + sispec.x + ", " + sispec.y +
				"] in the " + D2JSP_ITEM_CONT_ToName(sispec.container) + ".");
			for (count_2 = 0; count_2 < ISF_STASH_VAR_ID_MAX_TRY; count_2++) {
log_obj.logDetail("*** Identification attempt " + (count_2 + 1) +
	" --- identification delay = " + id_delay);
				// Grab the Tome of Identify...
				log_obj.logDetail("Selecting a Tome of Identify.");
				ibk_obj = D2JSP_COMM_GetALocalTome("ibk");
				if (!ibk_obj) {
					log_obj.logError("Unable to locate the ID tome scroll I just " +
						"determined was available!");
					return(ISF_STASH_RETURN_ID_TOME_ERROR);
				}
				// And use a scroll from it...
				log_obj.logDetail("Right-clicking the Tome of Identify (delay " +
					"before left-click on " + item_name + " is " + id_delay +
					" milliseconds).");
				clickItem(D2JSP_ITEM_CLICK_BUTTON_RIGHT, ibk_obj);
				// Wait a bit...
				D2JSP_UTIL_GEN_FuzzyDelay(id_delay);
				id_delay += 100;
				// Locate the item to be identified.
				log_obj.logDetail("Locating the " + item_name +
					" for identification.");
				if (!(this_obj = sispec.findItemExpected("to be identified")))
					return(ISF_STASH_RETURN_ITEM_NOT_FOUND);
				// Use the Tome of Identify on it...
				log_obj.logDetail("Left-clicking the " + item_name + ".");
				clickItem(D2JSP_ITEM_CLICK_BUTTON_LEFT, this_obj);
				D2JSP_UTIL_GEN_FuzzyDelay(100);
				for (count_3 = 0; count_3 < 40; count_3++) {
					if (this_obj.mode == D2JSP_MODE_ITEM_ON_CURSOR)
						break;
					else if (this_obj.getFlag(D2JSP_ITEMFLAG_IDENTIFIED))
						break;
					D2JSP_UTIL_GEN_FuzzyDelay(50);
				}
				if (this_obj.mode == D2JSP_MODE_ITEM_ON_CURSOR) {
					log_obj.logWarning("Identification attempt resulted in the " +
						"item being put on the cursor. Will attempt to return " +
						"said item to its original location at coordinates [" +
						sispec.x + ", " + sispec.y + "] for size " + sispec.xsize +
						", " + sispec.ysize + " in the " +
						D2JSP_ITEM_CONT_ToName(sispec.container) + ".");
					D2JSP_UTIL_GEN_FuzzyDelay(250);
					container_map_list = D2JSP_ITEM_CONT_BuildMapList();
D2JSP_ITEM_CONT_LogMapList(container_map_list);
log_obj.logDetail("X-coordinate = " + sispec.x);
log_obj.logDetail("Y-coordinate = " + sispec.y);
log_obj.logDetail("X-size       = " + sispec.xsize);
log_obj.logDetail("Y-size       = " + sispec.ysize);
log_obj.logDetail("Container Src= " + sispec.container + " = " + D2JSP_ITEM_CONT_ToName(sispec.container));
					if (!D2JSP_ITEM_CONT_ItemMoveTo(this_obj, sispec.container,
						sispec.x, sispec.y)) {
						log_obj.logFatal("Identification attempt resulted in the " +
							"item being put on the cursor and we are unable to " +
							"return said item to its original location: " +
							"D2JSP_ITEM_CONT_ItemMoveTo() failed, maps follow.");
						D2JSP_ITEM_CONT_LogMapList(container_map_list);
						return(ISF_STASH_RETURN_ID_FAILURE);
					}
					log_obj.logInfo("Item returned to its original location at " +
						"coordinates [" + sispec.x + ", " + sispec.y + "] for size " +
						sispec.xsize + ", " + sispec.ysize + " in the " +
						D2JSP_ITEM_CONT_ToName(sispec.container) + ".");
					D2JSP_UTIL_GEN_CancelObject(stash_obj);
					if ((stash_obj = D2JSP_COMM_InteractWithStash()) == null) {
						log_obj.logError("Unable to locate the stash.");
						return(ISF_STASH_RETURN_STASH_NOT_FOUND);
					}
				}
				if (this_obj && this_obj.getFlag(D2JSP_ITEMFLAG_IDENTIFIED))
					break;
				if (count_2 < (ISF_STASH_VAR_ID_MAX_TRY - 1))
					log_obj.logDetail("Identification attempt failed. " +
						"Will try again (attempt " + (count_2 + 1) + " of " +
						ISF_STASH_VAR_ID_MAX_TRY + ").");
				else
					log_obj.logWarning("Identification attempt failed. Maximum " +
						"number of attempts performed (" + ISF_STASH_VAR_ID_MAX_TRY +
						") --- giving up.");
			}
*/
			ISF_DoItemId(isf_cfg, stash_flags, sispec, "stash");
			if (!(this_obj = sispec.findItemExpected("just identified")))
				return(ISF_STASH_RETURN_ITEM_NOT_FOUND);
			if (this_obj.getFlag(D2JSP_ITEMFLAG_IDENTIFIED)) {
//				D2JSP_UTIL_GEN_FuzzyDelay(100);
				id_text = "Identified the " + item_name + " as a " +
					D2JSP_ITEM_ColorItemFixFName(this_obj);
				item_name = D2JSP_ITEM_ColorItemFixFName(this_obj);
				if ((results_data = ISF_EvalItemForKeep(isf_cfg, this_obj,
					ISF_EVAL_FLAG_RETURN_SOURCE_INFO))[0] == true) {
					// It's a keeper!
					log_obj.logEvaluate(id_text + ": this a definite keeper!");
					log_obj.logKeep("Item evaluation passed for: " +
						D2JSP_UTIL_FORMAT_LJust(item_name,
						D2JSP_ITEM_COLORED_ITEM_NAME_MAX)+
						isf_cfg[ISF_COMPILED_DATA_SPEC_LIST][results_data[1]].
						sourceStringFromISF(isf_cfg));
				}
				else {
					var old_log_file_level =
						log_obj.setLevelFile(D2JSP_UTIL_LOG_Level_MINUTIAE);
					var old_log_sync_level = log_obj.setSyncMode(true);
					// It's for the bin...
					log_obj.logEvaluate(id_text + ": this to be discarded.");
					log_obj.logDiscard("Item evaluation failed for: " + item_name);
					// Tell the core to put the item on the cursor...
					// ... and wait for it to get there.
					log_obj.logDetail("Discard attempt stage one for " + item_name +
						" at location [" + sispec.x + ", " + sispec.y + "] in the " +
						D2JSP_ITEM_CONT_ToName(sispec.container) + ". Will attempt " +
						"to move item to the cursor.");
					for (count_2 = 0; count_2 < 200; count_2++) {
						clickItem(D2JSP_ITEM_CLICK_BUTTON_LEFT, this_obj);
						delay(50);
						if (this_obj.mode == D2JSP_MODE_ITEM_ON_CURSOR)
							break;
						delay(250);
						if (this_obj.mode == D2JSP_MODE_ITEM_ON_CURSOR)
							break;
					}
					if (this_obj.mode != D2JSP_MODE_ITEM_ON_CURSOR) {
						log_obj.logError("Unable to move the item just identified "+
							"to the cursor.");
						log_obj.setLevelFile(old_log_file_level);
						log_obj.setSyncMode(old_log_sync_level);
						return(ISF_STASH_RETURN_MOVE_FAILURE);
					}
					log_obj.logDetail("Discard attempt stage two for " + item_name +
						" on the cursor. Will attempt to drop the item.");
					// Tell the core to drop it on the ground...
					this_obj.cancel();
					D2JSP_UTIL_GEN_FuzzyDelay(100);
					// ... and wait for it to get there.
					D2JSP_UTIL_GEN_CheckCursor(1000, 10);
					// We've got a serious problem if we can't clear the cursor.
					if (D2JSP_UTIL_GEN_ClearCursor(true, log_obj)) {
						log_obj.logFatal("Unable to clear cursor of discarded item.");
						log_obj.setLevelFile(old_log_file_level);
						log_obj.setSyncMode(old_log_sync_level);
						return(ISF_STASH_RETURN_CURSOR_ITEM_LOOP);
					}
					log_obj.logDetail("The " + item_name + " has been discarded.");
					log_obj.setLevelFile(old_log_file_level);
					log_obj.setSyncMode(old_log_sync_level);
					continue;
				}
			}
			//	///////////////////////////////////////////////////////////
			//	///////////////////////////////////////////////////////////
			// Our attempt to identify the item failed. Stash it anyway.
			//
			// The reason I do this is for unattended bot operation. Don't
			// want a full inventory when that uber item drops...
			//	///////////////////////////////////////////////////////////
			else if (sispec.container == D2JSP_ITEM_CONT_SRC_INVENTORY)
				log_obj.logError("Attempt to identify the " + item_name +
					" failed. Will attempt to stash it as is.");
			//	///////////////////////////////////////////////////////////
/*
			//	///////////////////////////////////////////////////////////
			//	///////////////////////////////////////////////////////////
			// Our attempt to identify the item failed. What should we do?
			//	///////////////////////////////////////////////////////////
			else {
				//	/////////////////////////////////////////////////////
				//	/////////////////////////////////////////////////////
				// If the item was originally found on the cursor, we'll
				// try to put it in the inventory so that it'll be
				// identified next run. Failing that, we'll try to get it
				// on the cursor for the same reason...
				//	/////////////////////////////////////////////////////
				if (sispec.cursor_item_flag) {
					this_obj.interact();
					// ... and wait for it to get there.
					while (!D2JSP_UTIL_GEN_CheckCursor())
						;
					D2JSP_UTIL_GEN_CancelObject(this_obj);
					D2JSP_UTIL_GEN_CancelObject(this_obj);
					D2JSP_UTIL_GEN_CheckCursor(1000, 10);
					if (stash_flags & ISF_STASH_FLAG_EXIT_ON_ID_FAILURE)
						return(ISF_STASH_RETURN_ID_FAILURE);
					continue;
				}
				//	/////////////////////////////////////////////////////
				//	/////////////////////////////////////////////////////
				// The user may want us to exit when we can't identify
				// an item...
				//	/////////////////////////////////////////////////////
				else if (stash_flags & ISF_STASH_FLAG_EXIT_ON_ID_FAILURE)
					return(ISF_STASH_RETURN_ID_FAILURE);
				//	/////////////////////////////////////////////////////
				//	/////////////////////////////////////////////////////
				// The reason we do this is for unattended bot operation. Don't
				// want a full inventory when that uber item drops...
				//	/////////////////////////////////////////////////////
				else if ((stash_flags & ISF_STASH_FLAG_STASH_ON_ID_FAILURE) &&
					(sispec.container == D2JSP_ITEM_CONT_SRC_INVENTORY))
					log_obj.logError("Attempt to identify the " + item_name +
						" failed. Will attempt to stash it as is.");
				else
***
			}
			//	///////////////////////////////////////////////////////////
*/
		}
		//	/////////////////////////////////////////////////////////////////
		//	/////////////////////////////////////////////////////////////////
		// If it's not in the inventory, consider it already stashed...
		//	/////////////////////////////////////////////////////////////////
		runGC();
		if (sispec.container != D2JSP_ITEM_CONT_SRC_INVENTORY)
			;
		//	/////////////////////////////////////////////////////////////////
		// If the item is identified, try first to put it in the cube...
		//
		// Don't want unided items in the cube as a visit to Cain will
		// identify them --- even if the cube is in the stash.
		//	/////////////////////////////////////////////////////////////////
/*
	CODE NOTE: To be removed.
else if (this_obj.getFlag(D2JSP_ITEMFLAG_IDENTIFIED)) {
	var move_data = D2JSP_ITEM_CONT_FindSpaceForItem(this_obj,
		container_map_list, D2JSP_ITEM_CONT_SRC_CUBE);
	if (move_data != null)
		print("Have space for " + item_name + " in " +
			D2JSP_ITEM_CONT_ToName(move_data[0]) + " at coordinates [" +
			move_data[1] + ", " + move_data[2] + "]");
	else
		print("No space for " + item_name + " in " +
			D2JSP_ITEM_CONT_ToName(D2JSP_ITEM_CONT_SRC_CUBE) + ".");
	print("Stopping"); stop();
}
*/
		else if (this_obj.getFlag(D2JSP_ITEMFLAG_IDENTIFIED) &&
			(!(stash_flags & ISF_STASH_FLAG_STASH_NOT_IN_CUBE)) &&
			D2JSP_ITEM_CONT_ItemMove(this_obj, container_map_list,
			D2JSP_ITEM_CONT_SRC_CUBE))
			log_obj.logInfo("Stashed the " + item_name + " in the " +
				D2JSP_ITEM_CONT_ToName(D2JSP_ITEM_CONT_SRC_CUBE) + ".");
		//	/////////////////////////////////////////////////////////////////
		//	/////////////////////////////////////////////////////////////////
		// Otherwise, put it in the stash...
		//
		// Not an error if the stash is full, of course...
		//	/////////////////////////////////////////////////////////////////
		else if (D2JSP_ITEM_CONT_ItemMove(this_obj, container_map_list,
			D2JSP_ITEM_CONT_SRC_STASH))
			log_obj.logInfo("Stashed the " + item_name + " in the " +
				D2JSP_ITEM_CONT_ToName(D2JSP_ITEM_CONT_SRC_STASH) + ".");
		else
			log_obj.logInfo("Unable to stash the " + item_name +
				", leaving it in the " + D2JSP_ITEM_CONT_ToName(sispec.container) +
				".");
		if (!sispec.id_flag) {
			D2JSP_UTIL_GEN_FuzzyDelay(ISF_DoItemIdDelay);
			if (ISF_DoItemIdDelay < 500)
				ISF_DoItemIdDelay += ISF_DoItemIdDelayDelta;
		}
		runGC();
	}

	return(return_code);
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
function ISF_DoSellingBasic(isf_cfg, exclude_list, stash_flags)
{
	var return_code = 0;
	var log_obj;
	var sell_list;

	log_obj = D2JSP_UTIL_LOG_GetALog();

	ISF_DoItemIdDelay = ISF_DoItemIdDelayBase;

	//	///////////////////////////////////////////////////////////////////////
	//	///////////////////////////////////////////////////////////////////////
	// Check to ensure there's nothing on the cursor... If there is, the
	// logic tries to move it so that it can proceed.
	//	///////////////////////////////////////////////////////////////////////
	if (ISF_CursorCheckStart(isf_cfg)) {
		log_obj.logFatal("Unable to perform selling while there is an item " +
			"on the cursor.");
		return(ISF_STASH_RETURN_CURSOR_ITEM_START);
	}
	//	///////////////////////////////////////////////////////////////////////

	//	///////////////////////////////////////////////////////////////////////
	//	///////////////////////////////////////////////////////////////////////
	// Have to be in town to sell...
	//	///////////////////////////////////////////////////////////////////////
	if (!D2JSP_AREA_IsTown()) {
		log_obj.logError("Unable to perform selling while not in town " +
			"(currently in " + D2JSP_AREA_AreaToName() + ").");
		return(ISF_STASH_RETURN_NOT_TOWN_ERROR);
	}
	//	///////////////////////////////////////////////////////////////////////

	//	///////////////////////////////////////////////////////////////////////
	//	///////////////////////////////////////////////////////////////////////
	// Get the list of items to sell...
	//	///////////////////////////////////////////////////////////////////////
	sell_list = ISF_GetSellActionList(isf_cfg, stash_flags, exclude_list);
	//	///////////////////////////////////////////////////////////////////////

	//	///////////////////////////////////////////////////////////////////////
	//	///////////////////////////////////////////////////////////////////////
	// Only the items which need to be identified in order to determine whether
	//	they'll be kept are candidates for selling if they fail the ISF 'KEEP'
	//	evaluation.
	//	///////////////////////////////////////////////////////////////////////
	for (var count_1 = 0; count_1 < sell_list.length; ) {
		if (sell_list[count_1].id_flag)
			count_1++;
		else
			sell_list.splice(count_1, 1);
	}
	//	///////////////////////////////////////////////////////////////////////

	if (sell_list.length)
		ISF_DoSellingInternal(isf_cfg, sell_list, stash_flags);

	if (ISF_GetStashActionListBasic(isf_cfg, false, stash_flags, exclude_list).
		length)
		return_code = ISF_DoStashing(isf_cfg, exclude_list, stash_flags);

	var stash_obj;
	if ((stash_obj = getUnit(D2JSP_UTIL_GETUNIT_OBJECT, "Bank")) != null)
		D2JSP_UTIL_GEN_CancelObject(stash_obj);

	return(return_code);
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
function ISF_DoSellingInternal(isf_cfg, sell_list, stash_flags)
{
	var return_code = 0;
	var id_count    = 0;
	var log_obj;
	var results_data;

	log_obj = D2JSP_UTIL_LOG_GetALog();

	ISF_DoItemIdDelay = ISF_DoItemIdDelayBase;

	//	///////////////////////////////////////////////////////////////////////
	//	///////////////////////////////////////////////////////////////////////
	// Check to ensure there's nothing on the cursor... If there is, the
	// logic tries to move it so that it can proceed.
	//	///////////////////////////////////////////////////////////////////////
	if (ISF_CursorCheckStart(isf_cfg)) {
		log_obj.logFatal("Unable to perform selling while there is an item " +
			"on the cursor.");
		return(ISF_STASH_RETURN_CURSOR_ITEM_START);
	}
	//	///////////////////////////////////////////////////////////////////////

	//	///////////////////////////////////////////////////////////////////////
	//	///////////////////////////////////////////////////////////////////////
	// Have to be in town to sell...
	//	///////////////////////////////////////////////////////////////////////
	if (!D2JSP_AREA_IsTown()) {
		log_obj.logError("Unable to perform selling while not in town " +
			"(currently in " + D2JSP_AREA_AreaToName() + ").");
		return(ISF_STASH_RETURN_NOT_TOWN_ERROR);
	}
	//	///////////////////////////////////////////////////////////////////////

	//	///////////////////////////////////////////////////////////////////////
	//	///////////////////////////////////////////////////////////////////////
	// If an empty list, we're basically done.
	//	///////////////////////////////////////////////////////////////////////
	if (!sell_list.length)
		return(ISF_STASH_RETURN_OK);
	//	///////////////////////////////////////////////////////////////////////

	//	///////////////////////////////////////////////////////////////////////
	//	///////////////////////////////////////////////////////////////////////
	// Count the number of items for stashing which need to be identified...
	//	///////////////////////////////////////////////////////////////////////
	for (var count_1 = 0; count_1 < sell_list.length; count_1++)
		id_count += (sell_list[count_1].id_flag) ? 1 : 0;
	//	///////////////////////////////////////////////////////////////////////

	log_obj.logInfo("There " + ((sell_list.length != 1) ? "are " : "is ") +
		sell_list.length + " item" + ((sell_list.length != 1) ? "s" : "") +
		" pending being sold an NPC, of which " + id_count + " need" +
		((id_count != 1) ? "" : "s") + " to be identified.");

	if (sell_list.length) {
		var max_gold_flag;
		var stash_list  = new Array();
		var npc_name    =
			D2JSP_NPC_GetVendorNameFromType(D2JSP_NPC_VENDOR_SCROLL);
		max_gold_flag = (!((me.getStat(D2JSP_STAT_LEVEL) * 10000) -
			me.getStat(D2JSP_STAT_GOLD))) ? true : false;
		if (D2JSP_NPC_MoveToNPC(npc_name))
			return(ISF_DoStashing(isf_cfg, exclude_list, stash_flags));
		D2JSP_NPC_TradeWithNPC(npc_name);
		while (sell_list.length) {
			var sispec  = sell_list[0];
			var id_flag = sispec.id_flag;
			if (!(return_code = ISF_DoItemId(isf_cfg, stash_flags, sispec,
				npc_name))) {
				var this_obj;
				if (!(this_obj = sispec.findItemExpected("just identified")))
					return(ISF_STASH_RETURN_ITEM_NOT_FOUND);
				else if (this_obj.getFlag(D2JSP_ITEMFLAG_IDENTIFIED)) {
					var item_name = D2JSP_ITEM_ColorItemFullName(this_obj);
					var id_text   = "Identified the " + item_name + " as a " +
						D2JSP_ITEM_ColorItemFixFName(this_obj);
					item_name = D2JSP_ITEM_ColorItemFixFName(this_obj);
					if ((results_data = ISF_EvalItemForKeep(isf_cfg, this_obj,
						ISF_EVAL_FLAG_RETURN_SOURCE_INFO))[0] == true) {
						// It's a keeper!
						log_obj.logEvaluate(id_text + ": this a definite keeper!");
						log_obj.logKeep("Item evaluation passed for: " +
							D2JSP_UTIL_FORMAT_LJust(item_name,
							D2JSP_ITEM_COLORED_ITEM_NAME_MAX)+
							isf_cfg[ISF_COMPILED_DATA_SPEC_LIST][results_data[1]].
							sourceStringFromISF(isf_cfg));
						sispec.id_flag = false;
						stash_list.push(sispec);
						if (!((me.getStat(D2JSP_STAT_LEVEL) * 10000) -
							me.getStat(D2JSP_STAT_GOLD)))
							max_gold_flag = true;
					}
					else {
						var old_log_file_level =
							log_obj.setLevelFile(D2JSP_UTIL_LOG_Level_MINUTIAE);
						var old_log_sync_level = log_obj.setSyncMode(true);
						// It's to be sold to an NPC...
						log_obj.logEvaluate(id_text + ": this to be sold.");
						// Tell the core to put the item on the cursor...
						// ... and wait for it to get there.
						log_obj.logDetail("Will attempt to sell the " + item_name +
							" to " + npc_name + ".");
						if (!D2JSP_NPC_SellToVendorBasic(npc_name, this_obj))
							log_obj.logDetail("The " + item_name + " has been sold " +
								"to " + npc_name + ".");
						else {		// Tell the core to drop it on the ground...
							log_obj.logWarning("Unable to sell the " + item_name +
								"to " + npc_name + " --- will discard it instead.");
							log_obj.logDiscard("Item sale failed for: " + item_name +
								" --- to be discarded instead.");
							for (var count_2 = 0; count_2 < 200; count_2++) {
								clickItem(D2JSP_ITEM_CLICK_BUTTON_LEFT, this_obj);
								delay(50);
								if (this_obj.mode == D2JSP_MODE_ITEM_ON_CURSOR)
									break;
								delay(250);
								if (this_obj.mode == D2JSP_MODE_ITEM_ON_CURSOR)
									break;
							}
							if (this_obj.mode != D2JSP_MODE_ITEM_ON_CURSOR) {
								log_obj.logError("Unable to move the item " +
									"to the cursor.");
								log_obj.setLevelFile(old_log_file_level);
								log_obj.setSyncMode(old_log_sync_level);
								return(ISF_STASH_RETURN_MOVE_FAILURE);
							}
							this_obj.cancel();
							D2JSP_UTIL_GEN_FuzzyDelay(100);
							// ... and wait for it to get there.
							D2JSP_UTIL_GEN_CheckCursor(1000, 10);
							// We've got a serious problem if we can't clear the cursor.
							if (D2JSP_UTIL_GEN_ClearCursor(true, log_obj)) {
								log_obj.logFatal("Unable to clear cursor of item " +
									"to be sold to " + npc_name + ".");
								log_obj.setLevelFile(old_log_file_level);
								log_obj.setSyncMode(old_log_sync_level);
								return(ISF_STASH_RETURN_CURSOR_ITEM_LOOP);
							}
						}
						log_obj.setLevelFile(old_log_file_level);
						log_obj.setSyncMode(old_log_sync_level);
					}
				}
			}
			sell_list.shift();
			runGC();
		}
		D2JSP_NPC_FillTomesAll();
		if (getUIFlag(D2JSP_UTIL_UI_NPC_MENU)) {
			var npc_obj;
			if ((npc_obj = D2JSP_NPC_GetNPC(npc_name)) != null)
				D2JSP_UTIL_GEN_CancelNPC(npc_obj);
		}
		if (max_gold_flag && ((me.getStat(D2JSP_STAT_LEVEL) * 10000) -
			me.getStat(D2JSP_STAT_GOLD)))
			ISF_DoPickup(null, ISF_PICKUP_FLAG_GOLD, 10, TDW_BELTMAN_FLAG_NONE,
				1000);
		if (stash_list.length) {
			return_code = ISF_DoStashingInternal(isf_cfg, stash_list, stash_flags);
			var stash_obj;
			if ((stash_obj = getUnit(D2JSP_UTIL_GETUNIT_OBJECT, "Bank")) != null)
				D2JSP_UTIL_GEN_CancelObject(stash_obj);
		}
	}

	return(return_code);
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
function ISF_GetStashActionNeedsList(isf_cfg, stash_flags, exclude_list)
{
	var stash_needs_list = new Array(5);
	var stash_action_list;
	var count_1;

	stash_needs_list[0] = 0;
	stash_needs_list[1] = 0;
	stash_needs_list[2] = 0;
	stash_needs_list[3] = 0;
	stash_needs_list[4] = ISF_GetStashActionListBasic(isf_cfg, false,
		stash_flags, exclude_list);

	stash_needs_list[0] = stash_needs_list[5].length;

	for (count_1 = 0; count_1 < stash_needs_list[5].length; count_2++) {
		if (stash_list[count_1].id_flag)
			stash_needs_list[1]++;
		else
			stash_needs_list[2]++;
		if (stash_list[count_1].cursor_item_flag)
			stash_needs_list[3]++;
	}
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
function ISF_GetStashActionList(isf_cfg, stash_flags, exclude_list)
{
	return(ISF_GetStashActionListBasic(isf_cfg, true, stash_flags,
		exclude_list));
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
function ISF_GetSellActionList(isf_cfg, stash_flags, exclude_list)
{
	return(ISF_GetStashActionListBasic(isf_cfg, false,
		stash_flags | ISF_STASH_FLAG_IGNORE_CURSOR_ITEM, exclude_list));
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
function ISF_GetStashActionListBasic(isf_cfg, action_flag, stash_flags,
	exclude_list)
{
	var stash_data  = new Array();
	var cursor_list = new Array();
	var results_data;
	var stash_action_list;
	var count_1;

	stash_data[ISF_STASH_ACTION_CTL_ISF_CFG]  = isf_cfg;
	stash_data[ISF_STASH_ACTION_CTL_FLAGS]    = stash_flags;
	stash_data[ISF_STASH_ACTION_CTL_EXCLUDE]  = new Array();
	stash_data[ISF_STASH_ACTION_CTL_MAP_LIST] =
		D2JSP_ITEM_CONT_BuildMapList();
	stash_data[ISF_STASH_ACTION_CTL_OUTPUT]   = new Array();

	// //////////////////////////////////////////////////////////////////////
	// //////////////////////////////////////////////////////////////////////
	// If the exclude list parameter was provided as a scalar, transform it
	// into an array.
	// //////////////////////////////////////////////////////////////////////
	if ((arguments.length >= 3) && (exclude_list != null) &&
		(!D2JSP_UTIL_GEN_TypeOfArray(exclude_list)))
		exclude_list = [exclude_list];
	// //////////////////////////////////////////////////////////////////////

	// //////////////////////////////////////////////////////////////////////
	// //////////////////////////////////////////////////////////////////////
	// If the exclude list parameter is not an associative array, make it one.
	// //////////////////////////////////////////////////////////////////////
	if (D2JSP_UTIL_GEN_TypeOfArrayHashed(exclude_list))
		stash_data[ISF_STASH_ACTION_CTL_EXCLUDE] = exclude_list;
	else if (D2JSP_UTIL_GEN_TypeOfArrayIndexed(exclude_list))
		stash_data[ISF_STASH_ACTION_CTL_EXCLUDE] =
			D2JSP_UTIL_GEN_ArrayIndexedToHashedShallow(exclude_list);
	// //////////////////////////////////////////////////////////////////////

	// //////////////////////////////////////////////////////////////////////
	// //////////////////////////////////////////////////////////////////////
	// Find all candidate items for stashing...
	// //////////////////////////////////////////////////////////////////////
	results_data = D2JSP_OBJ_IterateItem(stash_data, ISF_GetStashAction_Filter,
		null, null, D2JSP_MODE_ITEM_INVEN_STASH_CUBE_STORE);
	stash_action_list =
		results_data[D2JSP_OBJ_CALLBACK_DATA][ISF_STASH_ACTION_CTL_OUTPUT];
	// //////////////////////////////////////////////////////////////////////

	// //////////////////////////////////////////////////////////////////////
	// //////////////////////////////////////////////////////////////////////
	// If the function 'ISF_CursorCheckStart()' found something on the cursor
	// at the start of the game which potentially matched an ISF specification,
	// it would have tried to stash it. Append that item, if any...
	// //////////////////////////////////////////////////////////////////////
	if ((!(stash_flags & ISF_STASH_FLAG_IGNORE_CURSOR_ITEM)) &&
		ISF_PRIVATE_InstanceList[ISF_GetCursorItemName()].length) {
		cursor_list = ISF_PRIVATE_InstanceList[ISF_GetCursorItemName()];
		for (count_1 = 0; count_1 < cursor_list.length; count_1++) {
			if (cursor_list[count_1].findItem())
				stash_action_list.push(cursor_list[count_1]);
		}
		if (action_flag)
			ISF_PRIVATE_InstanceList[ISF_GetCursorItemName()].length = 0;
	}
	// //////////////////////////////////////////////////////////////////////

	runGC();

	return(stash_action_list);
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
function ISF_GetStashAction_Filter(this_obj, callback_data)
{
	var this_parent = this_obj.getParent();
	var return_code = false;
	var results_data;

	if (!(this_obj.code in callback_data[ISF_STASH_ACTION_CTL_EXCLUDE])) {
		if (this_parent && (this_parent.name == me.name) &&
			(D2JSP_ITEM_CONT_ItemContainer(this_obj) ==
			D2JSP_ITEM_CONT_SRC_INVENTORY)) {
			var itemtype = D2JSP_ITEM_GetItemType(this_obj);
			var category = D2JSP_ITEM_GetItemCategory(this_obj);
			if ((itemtype == D2JSP_ITEMTYPE_RUNE) ||
				 (itemtype == D2JSP_ITEMTYPE_GEM)  ||
				 (itemtype == D2JSP_ITEMTYPE_GEM0) ||
				 (itemtype == D2JSP_ITEMTYPE_GEM1) ||
				 (itemtype == D2JSP_ITEMTYPE_GEM2) ||
				 (itemtype == D2JSP_ITEMTYPE_GEM3) ||
				 (itemtype == D2JSP_ITEMTYPE_GEM4) ||
				 (itemtype == D2JSP_ITEMTYPE_GEMA) ||
				 (itemtype == D2JSP_ITEMTYPE_GEMD) ||
				 (itemtype == D2JSP_ITEMTYPE_GEME) ||
				 (itemtype == D2JSP_ITEMTYPE_GEMR) ||
				 (itemtype == D2JSP_ITEMTYPE_GEMS) ||
				 (itemtype == D2JSP_ITEMTYPE_GEMT) ||
				 (itemtype == D2JSP_ITEMTYPE_GEMZ)) {
				if ((!this_obj.getFlag(D2JSP_ITEMFLAG_IN_SOCKET)) &&
					((D2JSP_ITEM_HasHoradricCube() &&
					D2JSP_ITEM_CONT_FindSpaceForItem(this_obj,
					callback_data[ISF_STASH_ACTION_CTL_MAP_LIST],
					D2JSP_ITEM_CONT_SRC_CUBE)) ||
					D2JSP_ITEM_CONT_FindSpaceForItem(this_obj,
					callback_data[ISF_STASH_ACTION_CTL_MAP_LIST],
					D2JSP_ITEM_CONT_SRC_STASH))) {
					callback_data[ISF_STASH_ACTION_CTL_OUTPUT].
						push(new ISF_SISpec(this_obj, false, false, false));
					return_code = true;
				}
			}
			else if (!this_obj.getFlag(D2JSP_ITEMFLAG_IDENTIFIED)) {
				if ((typeof(callback_data[0]) == "object") &&
					((results_data = ISF_EvalItemForId(callback_data[0], this_obj,
					ISF_EVAL_FLAG_RETURN_SOURCE_INFO))[0] == true))
					callback_data[ISF_STASH_ACTION_CTL_OUTPUT].
						push(new ISF_SISpec(this_obj, true, false, true));
				else if (D2JSP_ITEM_CONT_FindSpaceForItem(this_obj,
					callback_data[ISF_STASH_ACTION_CTL_MAP_LIST],
					D2JSP_ITEM_CONT_SRC_STASH)) {
					if ((typeof(callback_data[0]) == "object") &&
						((results_data = ISF_EvalItemForKeep(callback_data[0],
						this_obj, ISF_EVAL_FLAG_RETURN_SOURCE_INFO))[0] == true))
						callback_data[ISF_STASH_ACTION_CTL_OUTPUT].
							push(new ISF_SISpec(this_obj, false, false, true));
					else if ((typeof(callback_data[0]) == "object") &&
						((results_data = ISF_EvalItemForPickup(callback_data[0],
						this_obj, ISF_EVAL_FLAG_RETURN_SOURCE_INFO))[0] == true))
						callback_data[ISF_STASH_ACTION_CTL_OUTPUT].
							push(new ISF_SISpec(this_obj, false, false, true));
					else
						callback_data[ISF_STASH_ACTION_CTL_OUTPUT].
							push(new ISF_SISpec(this_obj, false, false, false));
				}
				return_code = true;
			}
			else if ((this_obj.quality <= D2JSP_ITEM_QUALITY_SUPERIOR) &&
				(ISF_EvalItemForPickup(callback_data[0], this_obj,
				ISF_EVAL_FLAG_RETURN_SOURCE_INFO)[0] == true) &&
				D2JSP_ITEM_CONT_FindSpaceForItem(this_obj,
				callback_data[ISF_STASH_ACTION_CTL_MAP_LIST],
				D2JSP_ITEM_CONT_SRC_STASH)) {
				callback_data[ISF_STASH_ACTION_CTL_OUTPUT].
					push(new ISF_SISpec(this_obj, false, false, true));
				return_code = true;
			}
/*
			else if (ISF_EvalItemForKeep(callback_data[0], this_obj,
				ISF_EVAL_FLAG_RETURN_SOURCE_INFO)[0] == true) {
				callback_data[ISF_STASH_ACTION_CTL_OUTPUT].
					push(new ISF_SISpec(this_obj, false, false, true));
				return_code = true;
			}
*/
//			else if ((callback_data[ISF_STASH_ACTION_CTL_FLAGS] &
//				ISF_STASH_FLAG_OTHER_ITEMS) &&
			else if ((!this_obj.getFlag(D2JSP_ITEMFLAG_IN_SOCKET)) &&
				((category == "W") || (category == "A") ||
				((this_obj.code in D2JSP_ITEM_QuestItemCodeList) &&
				(this_obj.code != "box")) ||
				(this_obj.code == "jew") || (this_obj.code == "amu") ||
				(this_obj.code == "rin") || (this_obj.code == "cm1") ||
				(this_obj.code == "cm2") || (this_obj.code == "cm3") ||
				(this_obj.code == "ear"))) {
				if (!this_obj.getFlag(D2JSP_ITEMFLAG_IDENTIFIED)) {
					if (D2JSP_ITEM_CONT_FindSpaceForItem(this_obj,
						callback_data[ISF_STASH_ACTION_CTL_MAP_LIST],
						D2JSP_ITEM_CONT_SRC_STASH)) {
						callback_data[ISF_STASH_ACTION_CTL_OUTPUT].
							push(new ISF_SISpec(this_obj, false, false, false));
						return_code = true;
					}
				}
				else if ((this_obj.code != "cm1") && (this_obj.code != "cm2") &&
					(this_obj.code != "cm3") &&
					((D2JSP_ITEM_HasHoradricCube() &&
					D2JSP_ITEM_CONT_FindSpaceForItem(this_obj,
					callback_data[ISF_STASH_ACTION_CTL_MAP_LIST],
					D2JSP_ITEM_CONT_SRC_CUBE)) ||
					D2JSP_ITEM_CONT_FindSpaceForItem(this_obj,
					callback_data[ISF_STASH_ACTION_CTL_MAP_LIST],
					D2JSP_ITEM_CONT_SRC_STASH))) {
					callback_data[ISF_STASH_ACTION_CTL_OUTPUT].
						push(new ISF_SISpec(this_obj, false, false, false));
					return_code = true;
				}
			}
		}
	}

	return(return_code);
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
function ISF_GetMatchActionList(isf_cfg, stash_flags, exclude_list)
{
	var stash_data  = new Array();
	var cursor_list = new Array();
	var results_data;
	var stash_action_list;
	var count_1;

	stash_data[ISF_STASH_ACTION_CTL_ISF_CFG]  = isf_cfg;
	stash_data[ISF_STASH_ACTION_CTL_FLAGS]    = stash_flags;
	stash_data[ISF_STASH_ACTION_CTL_EXCLUDE]  = new Array();
	stash_data[ISF_STASH_ACTION_CTL_MAP_LIST] =
		D2JSP_ITEM_CONT_BuildMapList();
	stash_data[ISF_STASH_ACTION_CTL_OUTPUT]   = new Array();

	// //////////////////////////////////////////////////////////////////////
	// //////////////////////////////////////////////////////////////////////
	// If the exclude list parameter was provided as a scalar, transform it
	// into an array.
	// //////////////////////////////////////////////////////////////////////
	if ((arguments.length >= 3) && (exclude_list != null) &&
		(!D2JSP_UTIL_GEN_TypeOfArray(exclude_list)))
		exclude_list = [exclude_list];
	// //////////////////////////////////////////////////////////////////////

	// //////////////////////////////////////////////////////////////////////
	// //////////////////////////////////////////////////////////////////////
	// If the exclude list parameter is not an associative array, make it one.
	// //////////////////////////////////////////////////////////////////////
	if (D2JSP_UTIL_GEN_TypeOfArrayHashed(exclude_list))
		stash_data[ISF_STASH_ACTION_CTL_EXCLUDE] = exclude_list;
	else if (D2JSP_UTIL_GEN_TypeOfArrayIndexed(exclude_list))
		stash_data[ISF_STASH_ACTION_CTL_EXCLUDE] =
			D2JSP_UTIL_GEN_ArrayIndexedToHashedShallow(exclude_list);
	// //////////////////////////////////////////////////////////////////////

	// //////////////////////////////////////////////////////////////////////
	// //////////////////////////////////////////////////////////////////////
	// Find all candidate items for stashing...
	// //////////////////////////////////////////////////////////////////////
	results_data = D2JSP_OBJ_IterateItem(stash_data, ISF_GetMatchAction_Filter,
		null, null, D2JSP_MODE_ITEM_INVEN_STASH_CUBE_STORE);
	stash_action_list =
		results_data[D2JSP_OBJ_CALLBACK_DATA][ISF_STASH_ACTION_CTL_OUTPUT];
	// //////////////////////////////////////////////////////////////////////

	runGC();

	return(stash_action_list);
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
function ISF_GetMatchAction_Filter(this_obj, callback_data)
{
	var this_parent = this_obj.getParent();
	var return_code = false;
	var results_data;

	if (!(this_obj.code in callback_data[ISF_STASH_ACTION_CTL_EXCLUDE])) {
		if (this_parent && (this_parent.name == me.name) &&
			(D2JSP_ITEM_CONT_ItemContainer(this_obj) ==
			D2JSP_ITEM_CONT_SRC_INVENTORY)) {
			if (!this_obj.getFlag(D2JSP_ITEMFLAG_IDENTIFIED)) {
				if ((typeof(callback_data[0]) == "object") &&
					((results_data = ISF_EvalItemForId(callback_data[0], this_obj,
					ISF_EVAL_FLAG_RETURN_SOURCE_INFO))[0] == true))
					callback_data[ISF_STASH_ACTION_CTL_OUTPUT].
						push(new ISF_SISpec(this_obj, true, false, true));
				else if ((typeof(callback_data[0]) == "object") &&
					((results_data = ISF_EvalItemForKeep(callback_data[0], this_obj,
					ISF_EVAL_FLAG_RETURN_SOURCE_INFO))[0] == true))
					callback_data[ISF_STASH_ACTION_CTL_OUTPUT].
						push(new ISF_SISpec(this_obj, false, false, true));
				else if ((typeof(callback_data[0]) == "object") &&
					((results_data = ISF_EvalItemForPickup(callback_data[0], this_obj,
					ISF_EVAL_FLAG_RETURN_SOURCE_INFO))[0] == true))
					callback_data[ISF_STASH_ACTION_CTL_OUTPUT].
						push(new ISF_SISpec(this_obj, false, false, true));
				else
					callback_data[ISF_STASH_ACTION_CTL_OUTPUT].
						push(new ISF_SISpec(this_obj, false, false, false));
				return_code = true;
			}
			else if ((this_obj.quality <= D2JSP_ITEM_QUALITY_SUPERIOR) &&
				(ISF_EvalItemForPickup(callback_data[0], this_obj,
				ISF_EVAL_FLAG_RETURN_SOURCE_INFO)[0] == true)) {
				callback_data[ISF_STASH_ACTION_CTL_OUTPUT].
					push(new ISF_SISpec(this_obj, false, false, true));
				return_code = true;
			}
			else if (ISF_EvalItemForKeep(callback_data[0], this_obj,
				ISF_EVAL_FLAG_RETURN_SOURCE_INFO)[0] == true) {
				callback_data[ISF_STASH_ACTION_CTL_OUTPUT].
					push(new ISF_SISpec(this_obj, false, false, true));
				return_code = true;
			}
			else if (ISF_EvalItemForPickup(callback_data[0], this_obj,
				ISF_EVAL_FLAG_RETURN_SOURCE_INFO)[0] == true) {
				callback_data[ISF_STASH_ACTION_CTL_OUTPUT].
					push(new ISF_SISpec(this_obj, false, false, true));
				return_code = true;
			}
		}
	}

	return(return_code);
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
function ISF_DoItemId(isf_cfg, stash_flags, sispec, location)
{
	var return_code = ISF_STASH_RETURN_OK;
	var container_map_list;
	var log_obj;
	var old_log_file_level;
	var old_log_sync_level;
	var stash_obj;
	var count_1;
	var count_2;
	var count_3;
	var results_data;
	var isc_count;
	var ibk_obj;
	var this_obj;
	var item_name;
	var id_text;

	log_obj            = D2JSP_UTIL_LOG_GetALog();
	old_log_file_level = log_obj.setLevelFile(D2JSP_UTIL_LOG_Level_MINUTIAE);
	old_log_sync_level = log_obj.setSyncMode(true);

	ISF_DoItemIdDelay  = (ISF_DoItemIdDelay > ISF_DoItemIdDelayMax) ?
		ISF_DoItemIdDelayMax : ISF_DoItemIdDelay;

	container_map_list = D2JSP_ITEM_CONT_BuildMapList();


	//	/////////////////////////////////////////////////////////////////
	//	/////////////////////////////////////////////////////////////////
	// With many items to be identified, we can run out of scrolls
	// partway through the stashing process... So fix it...
	//	/////////////////////////////////////////////////////////////////
	if (sispec.id_flag) {
		ibk_obj = D2JSP_COMM_GetALocalTome("ibk");
		if (ibk_obj)
			isc_count = ibk_obj.getStat(D2JSP_STAT_QUANTITY);
		else {
			log_obj.logError("Just arranged to have an ID tome on hand, but " +
				"it seems to have vanished!");
			log_obj.setLevelFile(old_log_file_level);
			log_obj.setSyncMode(old_log_sync_level);
			return(ISF_STASH_RETURN_ID_TOME_ERROR);
		}
		if (!isc_count) {
			if ((location.toLowerCase() == "stash") ||
				(location.toLowerCase() == "bank")) {
				if ((stash_obj = D2JSP_COMM_InteractWithStash()) == null) {
					log_obj.logError("Unable to locate the stash.");
					log_obj.setLevelFile(old_log_file_level);
					log_obj.setSyncMode(old_log_sync_level);
					return(ISF_STASH_RETURN_STASH_NOT_FOUND);
				}
				D2JSP_UTIL_GEN_CancelObject(stash_obj);
				D2JSP_UTIL_GEN_FuzzyDelay(250);
			}
			if (D2JSP_NPC_FillIBK()) {
				log_obj.logError("Was unable to re-fill an ID tome");
				log_obj.setLevelFile(old_log_file_level);
				log_obj.setSyncMode(old_log_sync_level);
				return(ISF_STASH_RETURN_ID_TOME_ERROR);
			}
			D2JSP_NPC_FillTomesAll();
			isc_count = 20;
			if ((location.toLowerCase() == "stash") ||
				(location.toLowerCase() == "bank")) {
				if ((stash_obj = D2JSP_COMM_InteractWithStash()) == null) {
					log_obj.logError("Unable to locate the stash.");
					log_obj.setLevelFile(old_log_file_level);
					log_obj.setSyncMode(old_log_sync_level);
					return(ISF_STASH_RETURN_STASH_NOT_FOUND);
				}
			}
			else
				D2JSP_NPC_TradeWithNPC(location);
			ISF_DoItemIdDelay = ISF_DoItemIdDelayBase;
		}
		ibk_obj = D2JSP_COMM_GetALocalTome("ibk");
		if (!ibk_obj) {
			log_obj.logError("Unable to locate the ID tome scroll I just " +
				"determined was available!");
			log_obj.setLevelFile(old_log_file_level);
			log_obj.setSyncMode(old_log_sync_level);
			return(ISF_STASH_RETURN_ID_TOME_ERROR);
		}
	}
	//	/////////////////////////////////////////////////////////////////

	//	/////////////////////////////////////////////////////////////////
	//	/////////////////////////////////////////////////////////////////
	// Get the item we determined needed stashing...
	//
	// If not found, I continue with the other items. The reason it's not
	// a fatal error is that the user may have interactively moved the
	// item out of inventory. Or identified it. Or something.
	//	/////////////////////////////////////////////////////////////////
	if (!(this_obj = sispec.findItemExpected("found previously"))) {
		log_obj.setLevelFile(old_log_file_level);
		log_obj.setSyncMode(old_log_sync_level);
		return(0);
	}
	//	/////////////////////////////////////////////////////////////////

	//	/////////////////////////////////////////////////////////////////
	item_name = D2JSP_ITEM_ColorItemFullName(this_obj);
	if (sispec.id_flag) {
		//	///////////////////////////////////////////////////////////
		//	///////////////////////////////////////////////////////////
		// Identify this item...
		//	///////////////////////////////////////////////////////////
		log_obj.logDetail("Beginning identification attempt for " +
			item_name + " at location [" + sispec.x + ", " + sispec.y +
			"] in the " + D2JSP_ITEM_CONT_ToName(sispec.container) + ".");
		for (count_2 = 0; count_2 < ISF_STASH_VAR_ID_MAX_TRY; count_2++) {
			runGC();
			log_obj.logDebug("*** Identification attempt " + (count_2 + 1) +
					" --- identification delay = " + ISF_DoItemIdDelay);
			// Grab the Tome of Identify...
			log_obj.logDetail("Selecting a Tome of Identify.");
			ibk_obj = D2JSP_COMM_GetALocalTome("ibk");
			if (!ibk_obj) {
				log_obj.logError("Unable to locate the ID tome scroll I just " +
					"determined was available!");
				log_obj.setLevelFile(old_log_file_level);
				log_obj.setSyncMode(old_log_sync_level);
				return(ISF_STASH_RETURN_ID_TOME_ERROR);
			}
			// And use a scroll from it...
			log_obj.logDetail("Right-clicking the Tome of Identify (delay " +
				"before left-click on " + item_name + " is " + ISF_DoItemIdDelay +
				" milliseconds).");
			clickItem(D2JSP_ITEM_CLICK_BUTTON_RIGHT, ibk_obj);
			// Wait a bit...
			D2JSP_UTIL_GEN_FuzzyDelay(ISF_DoItemIdDelay);
			ISF_DoItemIdDelay += ISF_DoItemIdDelayDelta;
			// Locate the item to be identified.
			log_obj.logDetail("Locating the " + item_name +
				" for identification.");
			if (!(this_obj = sispec.findItemExpected("to be identified"))) {
				log_obj.setLevelFile(old_log_file_level);
				log_obj.setSyncMode(old_log_sync_level);
				return(ISF_STASH_RETURN_ITEM_NOT_FOUND);
			}
			// Use the Tome of Identify on it...
			log_obj.logDetail("Left-clicking the " + item_name + ".");
			clickItem(D2JSP_ITEM_CLICK_BUTTON_LEFT, this_obj);
			D2JSP_UTIL_GEN_FuzzyDelay(100);
			for (count_3 = 0; count_3 < 40; count_3++) {
				if (this_obj.mode == D2JSP_MODE_ITEM_ON_CURSOR)
					break;
				else if (this_obj.getFlag(D2JSP_ITEMFLAG_IDENTIFIED))
					break;
				D2JSP_UTIL_GEN_FuzzyDelay(50);
			}
			runGC();
			if (this_obj.mode == D2JSP_MODE_ITEM_ON_CURSOR) {
				log_obj.logWarning("Identification attempt resulted in the " +
					"item being put on the cursor. Will attempt to return " +
					"said item to its original location at coordinates [" +
					sispec.x + ", " + sispec.y + "] for size " + sispec.xsize +
					", " + sispec.ysize + " in the " +
					D2JSP_ITEM_CONT_ToName(sispec.container) + ".");
				D2JSP_UTIL_GEN_FuzzyDelay(250);
				container_map_list = D2JSP_ITEM_CONT_BuildMapList();
				D2JSP_ITEM_CONT_LogMapList(container_map_list);
				log_obj.logDetail("X-coordinate = " + sispec.x);
				log_obj.logDetail("Y-coordinate = " + sispec.y);
				log_obj.logDetail("X-size       = " + sispec.xsize);
				log_obj.logDetail("Y-size       = " + sispec.ysize);
				log_obj.logDetail("Container Src= " + sispec.container + " = " +
					D2JSP_ITEM_CONT_ToName(sispec.container));
/*
				if (!D2JSP_ITEM_CONT_UpdateMapList(sispec.x, sispec.y,
					sispec.xsize, sispec.ysize, sispec.container,
					container_map_list, 0)) {
					log_obj.logFatal("Identification attempt resulted in the " +
						"item being put on the cursor and we are unable to " +
						"return said item to its original location: " +
						"D2JSP_ITEM_CONT_UpdateMapList() failed, maps follow.");
					D2JSP_ITEM_CONT_LogMapList(container_map_list);
					log_obj.setLevelFile(old_log_file_level);
					log_obj.setSyncMode(old_log_sync_level);
					return(ISF_STASH_RETURN_ID_FAILURE);
				}
*/
				if (!D2JSP_ITEM_CONT_ItemMoveTo(this_obj, sispec.container,
					sispec.x, sispec.y)) {
					log_obj.logFatal("Identification attempt resulted in the " +
						"item being put on the cursor and we are unable to " +
						"return said item to its original location: " +
						"D2JSP_ITEM_CONT_ItemMoveTo() failed, maps follow.");
					D2JSP_ITEM_CONT_LogMapList(container_map_list);
					log_obj.setLevelFile(old_log_file_level);
					log_obj.setSyncMode(old_log_sync_level);
					return(ISF_STASH_RETURN_ID_FAILURE);
				}
				log_obj.logInfo("Item returned to its original location at " +
					"coordinates [" + sispec.x + ", " + sispec.y + "] for size " +
					sispec.xsize + ", " + sispec.ysize + " in the " +
					D2JSP_ITEM_CONT_ToName(sispec.container) + ".");

				if ((location.toLowerCase() == "stash") ||
					(location.toLowerCase() == "bank")) {
					if ((stash_obj = D2JSP_COMM_InteractWithStash()) != null)
						D2JSP_UTIL_GEN_CancelObject(stash_obj);
					if ((stash_obj = D2JSP_COMM_InteractWithStash()) == null) {
						log_obj.logError("Unable to locate the stash.");
						log_obj.setLevelFile(old_log_file_level);
						log_obj.setSyncMode(old_log_sync_level);
						return(ISF_STASH_RETURN_STASH_NOT_FOUND);
					}
				}
/*
				else {
					D2JSP_UTIL_GEN_FuzzyDelay(250);
					D2JSP_COMM_CancelUIMenu(npc_obj);
					D2JSP_UTIL_GEN_FuzzyDelay(100);
					D2JSP_UTIL_GEN_CancelNPC(npc_obj);
					D2JSP_UTIL_GEN_FuzzyDelay(250);
				}
*/
				runGC();
			}
			if (!(this_obj = sispec.findItemExpected("to be identified"))) {
				log_obj.setLevelFile(old_log_file_level);
				log_obj.setSyncMode(old_log_sync_level);
				return(ISF_STASH_RETURN_ITEM_NOT_FOUND);
			}
			if (this_obj && this_obj.getFlag(D2JSP_ITEMFLAG_IDENTIFIED))
				break;
			if (count_2 < (ISF_STASH_VAR_ID_MAX_TRY - 1))
				log_obj.logDetail("Identification attempt failed. " +
					"Will try again (attempt " + (count_2 + 1) + " of " +
					ISF_STASH_VAR_ID_MAX_TRY + ").");
			else
				log_obj.logWarning("Identification attempt failed. Maximum " +
					"number of attempts performed (" + ISF_STASH_VAR_ID_MAX_TRY +
					") --- giving up.");
		}
	}

	log_obj.setLevelFile(old_log_file_level);
	log_obj.setSyncMode(old_log_sync_level);

	runGC();

	return(return_code);
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
function ISF_EvalItem(eval_index, isf_cfg, __PISF_item_obj__, eval_flags)
{
	var this_code;
	var this_prior;
	var count_1;

	if ((typeof(__PISF_item_obj__) != "object") ||
		(typeof(__PISF_item_obj__.code) != "string"))
		return((eval_flags & ISF_EVAL_FLAG_RETURN_SOURCE_INFO) ?
			[false, 0] : false);

	this_code = __PISF_item_obj__.code;

	for (this_prior = 0; this_prior < isf_cfg[eval_index].length; this_prior++) {
		if (typeof(isf_cfg[eval_index][this_prior][this_code]) != "undefined") {
			for (count_1 = 0;
				count_1 < isf_cfg[eval_index][this_prior][this_code].length;
				count_1++) {
				if ((isf_cfg[eval_index][this_prior][this_code][count_1][1] == "")||
					eval(isf_cfg[eval_index][this_prior][this_code][count_1][1]))
					return((eval_flags & ISF_EVAL_FLAG_RETURN_SOURCE_INFO) ?
						[true,
						isf_cfg[eval_index][this_prior][this_code][count_1][0]] :
						true);
			}
		}
	}

	return((eval_flags & ISF_EVAL_FLAG_RETURN_SOURCE_INFO) ?
		[false, 0] : false);
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
function ISF_ItemIsListed(isf_cfg, __PISF_item_obj__, eval_flags)
{
	var eval_index = ISF_COMPILED_DATA_EVAL;
	var this_code;
	var this_prior;

	if ((typeof(__PISF_item_obj__) != "object") ||
		(typeof(__PISF_item_obj__.code) != "string"))
		return(false);

	this_code = __PISF_item_obj__.code;

	for (this_prior = 0; this_prior < isf_cfg[eval_index].length; this_prior++) {
		if (typeof(isf_cfg[eval_index][this_prior][this_code]) != "undefined")
			return((eval_flags & ISF_EVAL_FLAG_RETURN_SOURCE_INFO) ?
				[true, isf_cfg[eval_index][this_prior][this_code][0][0]] : true);
	}

	return((eval_flags & ISF_EVAL_FLAG_RETURN_SOURCE_INFO) ?
		[false, 0] : false);
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
// ////////////////////////////////////////////////////////////////////////////
// The ISF_PUSpec object contains the data descibing an item to be picked up
// and methods for managing that operation.
// ////////////////////////////////////////////////////////////////////////////
// The ISF_PUSpec constructor
function ISF_PUSpec(in_obj, priority, distance, isf_flag, other)
{
//	this.code          = new String(in_obj.code);
	this.code          = in_obj.code;
	this.x             = D2JSP_UTIL_GEN_CloneObject(in_obj.x);
	this.y             = D2JSP_UTIL_GEN_CloneObject(in_obj.y);
	this.quality       = D2JSP_UTIL_GEN_CloneObject(in_obj.quality);
	this.itemclass     = D2JSP_ITEM_GetItemClass(in_obj);
	this.xsize         = D2JSP_ITEM_GetItemXSize(in_obj);
	this.ysize         = D2JSP_ITEM_GetItemYSize(in_obj);
	this.mode          = D2JSP_UTIL_GEN_CloneObject(in_obj.mode);
	this.priority      = priority;
	this.distance      = distance;
	this.distance_now  = distance;
	this.isf_flag      = (isf_flag) ? true : false;
	this.other         = other;
	this.fullNameColor = D2JSP_ITEM_ColorItemFullName(in_obj);
	this.findDrop      = ISF_PUSpec_findDrop;
	this.findDropBasic = ISF_PUSpec_findDropBasic;
	this.waitForPickup = ISF_PUSpec_waitForPickup;
	this.toString      = ISF_PUSpec_toString;
}
//-----------------------------------------------------------------------------
// The basic functionality to locate the dropped object using the ISF_PUSpec
function ISF_PUSpec_findDropBasic()
{
	var this_obj;

	this_obj = getUnit(D2JSP_UTIL_GETUNIT_ITEM, this.code,
		ISF_ITEM_PICKUP_MODE_FLAGS);

	if (this_obj) {
		do {
			if (((this_obj.mode == D2JSP_MODE_ITEM_ON_GROUND) ||
				(this_obj.mode == D2JSP_MODE_ITEM_BEING_DROPPED)) &&
				(this_obj.code == this.code) &&
				(this_obj.quality == this.quality) &&
				(this_obj.x == this.x) &&
				(this_obj.y == this.y))
				return(this_obj);
		} while (this_obj &&
			this_obj.getNext(this.code, ISF_ITEM_PICKUP_MODE_FLAGS));
	}

	return(null);
}
//-----------------------------------------------------------------------------
// Iterative functionality to locate the dropped object using the ISF_PUSpec
function ISF_PUSpec_findDrop()
{
	var this_obj;
	var count_1;

	for (count_1 = 0; count_1 < 10; count_1++) {
		if ((this_obj = this.findDropBasic()) != null)
			return(this_obj);
	}

	return(null);
}
//-----------------------------------------------------------------------------
// Iterative functionality to determine when the dropped object is picked up
// (picked up by someone, not neccessarily your character).
function ISF_PUSpec_waitForPickup(iter_count)
{
	var start_time = new Date();
	var this_count = 0;
	var end_time;

	iter_count = (iter_count > 0) ? iter_count : 1;

	end_time   = start_time.valueOf() + (iter_count * 50);

	while ((new Date()).valueOf() < end_time) {
		if (!this.findDropBasic())
{
	if (TDW_BOT_Log)
		TDW_BOT_Log.logMinutiae("***** " + this.fullNameColor +
			" pickup time = " + ((new Date()).valueOf() - start_time) +
			", iterations = " + this_count);
			return(true);
}
		delay(50);
		this_count++;
	}

	return(false);
}
//-----------------------------------------------------------------------------
// Used only in debugging this code.
function ISF_PUSpec_toString()
{
	return([this.priority, this.distance, this.code, this.x, this.y, this.xsize,
		this.ysize, this.mode, this.quality, this.itemclass, this.isf_flag,
		this.other] + "");
}
//-----------------------------------------------------------------------------
// Sorts a list of ISF_PUSpecs representing items by 1) their ISF priority and
// 2) their distance from the character. May not be the best algorithmic
// approach...
function ISF_PUSpecSortItemsList(pickup_spec_list)
{
	pickup_spec_list.sort(function(item_1, item_2) {
		return((item_1.priority < item_2.priority) ? -1 :
			(item_1.priority > item_2.priority) ? 1 :
			(item_1.distance < item_2.distance) ? -1 :
			(item_1.distance > item_2.distance) ? 1 : 0); });
}
//-----------------------------------------------------------------------------
// Provided for orthogonality. Belt manager does the ordering of potions.
function ISF_PUSpecSortBeltList(pickup_spec_list)
{
}
//-----------------------------------------------------------------------------
// Sorts a list of ISF_PUSpecs representing gold stacks by 1) their distance
// from the character and 2) the amount of gold in the stack. May not be the
// best algorithmic approach...
function ISF_PUSpecSortGoldList(pickup_spec_list)
{
	pickup_spec_list.sort(function(item_1, item_2) {
		return((item_1.distance < item_2.distance) ? -1 :
			(item_1.distance > item_2.distance) ? 1 :
			(item_1.other < item_2.other) ? -1 :
			(item_1.other > item_2.other) ? 1 : 0); });
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
var ISF_ITEM_PICKUP_MODE_FLAGS = D2JSP_MODE_FLAG_INDICATOR |
		(1 << D2JSP_MODE_ITEM_ON_GROUND) | (1 << D2JSP_MODE_ITEM_BEING_DROPPED);
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
function ISF_CreatePickupList(isf_cfg, pickup_flags, pickup_radius, belt_flags,
	min_gold_amount)
{
	var item_list       = new Array();
	var belt_list       = new Array();
	var gold_list       = new Array();
	var belt_needs_list = new Array();
	var i_belt_list     = new Array();
	var o_belt_list     = new Array();
	var belt_pickup;
	var my_belt;
	var results_data;

//print("mode flags = " + ISF_ITEM_PICKUP_MODE_FLAGS.toString(16));
//print("STOPPING");
//stop();

	ISF_LastPickupNoSpace = new Array();

	pickup_flags          = (pickup_flags != null) ? pickup_flags :
		ISF_PICKUP_FLAG_DEFAULT;

	pickup_radius         = ((arguments.length >= 2) &&
		(typeof(pickup_radius) == "number") && (pickup_radius > 0)) ?
		pickup_radius : 40;

	belt_pickup           = pickup_flags &
		(ISF_PICKUP_FLAG_BELT_SIMPLE | ISF_PICKUP_FLAG_BELT_SMART) ;

	if ((isf_cfg == null) && (!belt_pickup) && (!min_gold_amount))
		return(new Array());

	if (pickup_flags & ISF_PICKUP_FLAG_BELT_SMART) {
		my_belt         = new TDW_BELTMAN_BeltInfo();
		belt_needs_list = my_belt.getNeededList(belt_flags);
	}

//var log_obj = D2JSP_UTIL_LOG_GetALog();

	var telekinesis_flag = D2JSP_SKILL_CanTelekinesisHere();

	if (!telekinesis_flag)
		pickup_flags |= ISF_PICKUP_FLAG_FAST_USE_ANY;

	var this_obj = getUnit(D2JSP_UTIL_GETUNIT_ITEM, null,
		ISF_ITEM_PICKUP_MODE_FLAGS);

	if (this_obj) {
		do {
			var this_distance = Dist(me.x, me.y, this_obj.x, this_obj.y);
			var fast_snag = ((this_obj.code == "gld") ||
				(this_obj.code in D2JSP_ITEM_BeltCellUpgrades)) ? true : false;
			if (fast_snag && (!(pickup_flags & ISF_PICKUP_FLAG_FAST_USE_ANY)) &&
				((!telekinesis_flag) || (this_distance >= 18)))
				;
			else if (((this_obj.mode == D2JSP_MODE_ITEM_ON_GROUND) ||
				(this_obj.mode == D2JSP_MODE_ITEM_BEING_DROPPED)) &&
				(this_distance <= pickup_radius)) {
				if ((isf_cfg != null) &&
					(results_data = ISF_EvalItemForPickup(isf_cfg, this_obj,
					ISF_EVAL_FLAG_RETURN_SOURCE_INFO))[0] == true)
					item_list.push(new ISF_PUSpec(this_obj, 0, this_distance, true,
						results_data[1]));
				else if ((pickup_flags & ISF_PICKUP_FLAG_BELT_SIMPLE) &&
					(this_obj.code in ISF_PickupBeltNeedsList) &&
					(ISF_PickupBeltNeedsList[this_obj.code] > 0)) {
					item_list.push(new ISF_PUSpec(this_obj,
						ISF_SPEC_ITEM_PRIORITY_BELT, this_distance, false, 0));
					ISF_PickupBeltNeedsList[this_obj.code]--;
				}
				else if ((pickup_flags & ISF_PICKUP_FLAG_BELT_SMART) &&
					(this_obj.code in belt_needs_list))
					i_belt_list.push([this_obj.code,
						new ISF_PUSpec(this_obj, ISF_SPEC_ITEM_PRIORITY_BELT,
						this_distance, false, 0)]);
				else if (min_gold_amount && (this_obj.code == "gld") && 
					(this_obj.getStat(D2JSP_STAT_GOLD) >= min_gold_amount))
					gold_list.push(new ISF_PUSpec(this_obj,
						ISF_SPEC_ITEM_PRIORITY_GOLD, this_distance, false,
						this_obj.getStat(D2JSP_STAT_GOLD)));
//log_obj.logInfoQuiet("ISF PRE-PICKUP: " + D2JSP_ITEM_ColorItemFullName(this_obj));
			}
		} while (this_obj && this_obj.getNext(null, ISF_ITEM_PICKUP_MODE_FLAGS));
	}

	ISF_PUSpecSortItemsList(item_list);
	ISF_PUSpecSortItemsList(gold_list);

	if ((pickup_flags & ISF_PICKUP_FLAG_BELT_SMART) && i_belt_list.length) {
		o_belt_list = my_belt.getActionList(i_belt_list, belt_flags);
		for (count_1 = 0; count_1 < o_belt_list.length; count_1++)
			belt_list.push(o_belt_list[count_1][TDW_BELTMAN_ITEM_OUT_IN_DATA]
				[TDW_BELTMAN_ITEM_IN_OTHER]);
	}

	runGC();

	return(item_list.concat(belt_list, gold_list));
}
// ////////////////////////////////////////////////////////////////////////////

// CODE NOTE: To be removed.
// ////////////////////////////////////////////////////////////////////////////
function ISF_ComparePickupItems(item_1, item_2)
{
	return((item_1[0] < item_2[0]) ? -1 : (item_1[0] > item_2[0]) ? 1 :
		(item_1[1] < item_2[1]) ? -1 : (item_1[1] > item_2[1]) ? 1 : 0);
}
// ////////////////////////////////////////////////////////////////////////////

// CODE NOTE: To be removed.
// ////////////////////////////////////////////////////////////////////////////
function ISF_ComparePickupGold(item_1, item_2)
{
	return((item_1[1] < item_2[1]) ? -1 : (item_1[1] > item_2[1]) ? 1 :
		(item_1[7] > item_2[7]) ? -1 : (item_1[7] < item_2[7]) ? 1 : 0);
}
// ////////////////////////////////////////////////////////////////////////////

// CODE NOTE: The callback functionality is to be completely re-factored.
// Callbacks will be made at various stages of a pickup, with the callback
// function able to modify some of the pickup operations in real-time.
// ////////////////////////////////////////////////////////////////////////////
function ISF_DoPickupBasic(isf_cfg, pickup_list, pickup_flags, destination,
	callback_func, callback_data)
{
	var return_code       = 0;
	var original_location = new Array(2);
	var telekinesis_flag  = false;
	var teleport_flag     = false;
	var did_move          = false;
	var puspec;
	var log_obj;
	var this_obj;
	var gold_room;
	var gold_start;
	var left_skill;
	var count_1;
	var count_2;
	var will_fit_flag;
	var snag_start;
	var snag_time;
	var error_msg_string;

	ISF_LastPickupNoSpace = new Array();

	callback_func = (D2JSP_UTIL_GEN_TypeOfFunction(callback_func)) ?
		callback_func : null;


	original_location[0]  = me.x;
	original_location[1]  = me.y;

	if (!pickup_list.length)
		return(return_code);

	log_obj = D2JSP_UTIL_LOG_GetALog();

/*
	if (me.classid == D2JSP_CLASS_ID_SORCERESS) {
		left_skill       = me.getSkill(0);
		telekinesis_flag = (me.getSkill(D2JSP_SKILL_TELEKINESIS, 0)) ? true : false;
		teleport_flag    = (me.getSkill(D2JSP_SKILL_TELEPORT, 0) &&
			(!D2JSP_AREA_IsTown())) ? true : false;
	}
*/

	left_skill       = me.getSkill(0);
	telekinesis_flag = D2JSP_SKILL_CanTelekinesisHere();
	teleport_flag    = D2JSP_SKILL_CanTeleportHere();

	if (!telekinesis_flag)
		pickup_flags |= ISF_PICKUP_FLAG_FAST_USE_ANY;

	if (log_obj.getLevelFile() <= D2JSP_UTIL_LOG_Level_MINUTIAE) {
		log_obj.logMinutiae("Pickup list to be processed:");
		for (count_1 = 0; count_1 < pickup_list.length; count_1++)
			log_obj.logMinutiae(D2JSP_UTIL_FORMAT_RJust(count_1 + "", 10) +
				" = [" + pickup_list[count_1] + "]");
		log_obj.flushLog();
	}

	ISF_CB_InfoPickup.stage    = ISF_CB_INFO_STAGE_PICKUP_START;
	ISF_CB_InfoPickup.list     = pickup_list;
	ISF_CB_InfoPickup.index    = 0;
	ISF_CB_InfoPickup.item     = null;
	ISF_CB_InfoPickup.distance = 0;
	ISF_CB_InfoPickup.will_fit = false;
	if (callback_func && callback_func(ISF_CB_TYPE_PICKUP_ITEM,
		ISF_CB_InfoPickup, callback_data))
		pickup_list = new Array();

	for (count_1 = 0; count_1 < pickup_list.length; count_1++) {
		runGC();
		puspec        = pickup_list[count_1];
		will_fit_flag = true;
		if (puspec.code == "gld") {
			gold_room = (me.getStat(D2JSP_STAT_LEVEL) * 10000) -
				me.getStat(D2JSP_STAT_GOLD);
			if (!gold_room)
				continue;
		}
		else if (puspec.isf_flag && (!D2JSP_ITEM_CONT_FindSpace(puspec.xsize,
			puspec.ysize, D2JSP_ITEM_CONT_BuildMapList(),
			D2JSP_ITEM_CONT_SRC_INVENTORY))) {
			ISF_LastPickupNoSpace.push(puspec);
			if (!(pickup_flags & ISF_PICKUP_FLAG_CURSOR)) {
				log_obj.logWarning("We will NOT snag a " + puspec.fullNameColor +
					" because it will not fit into the inventory.");
				continue;
			}
			else {
				log_obj.logWarning("We intend to snag a " + puspec.fullNameColor +
					" which will not fit into the inventory.");
				will_fit_flag = false;
			}
		}
		this_obj  = puspec.findDrop();
		var this_move = false;
		if (!this_obj) {
			log_obj.logWarning("Unable to find expected " + puspec.fullNameColor +
				" at [" + puspec.x + ", " + puspec.y + "] --- it may have " +
				"already been picked up.");
			continue;
		}
		puspec.distance_now = Dist(me.x, me.y, this_obj.x, this_obj.y);
		var fast_snag = ((puspec.code == "gld") ||
			(puspec.code in D2JSP_ITEM_BeltCellUpgrades)) ? true : false;
		if (fast_snag && (!(pickup_flags & ISF_PICKUP_FLAG_FAST_USE_ANY)) &&
			((!telekinesis_flag) || (puspec.distance_now >= 20))) {
			if (log_obj.getLevelFile() <= D2JSP_UTIL_LOG_Level_DETAIL)
				log_obj.logDetail("Will not snag " + puspec.fullNameColor +
					" because telekinesis is not avaliable for snagging.");
			continue;
		}
		ISF_CB_InfoPickup.stage    = ISF_CB_INFO_STAGE_PICKUP_BEFORE;
		ISF_CB_InfoPickup.index    = count_1;
		ISF_CB_InfoPickup.item     = this_obj;
		ISF_CB_InfoPickup.distance = puspec.distance_now;
		ISF_CB_InfoPickup.will_fit = will_fit_flag;
		if (callback_func && callback_func(ISF_CB_TYPE_PICKUP_ITEM,
			ISF_CB_InfoPickup, callback_data))
			break;
		if (log_obj.getLevelFile() <= D2JSP_UTIL_LOG_Level_DETAIL)
			log_obj.logDetail("Intend to snag " + puspec.fullNameColor +
				": distance = " + puspec.distance_now + ", mode = " +
				this_obj.mode);
		D2JSP_UTIL_GEN_CheckCursor(50);
		if (D2JSP_UTIL_GEN_ClearCursor(false, log_obj)) {
			log_obj.logFatal("Pickup list aborted due to item on cursor (" +
				"return_code = -1)");
			log_obj.flushLog();
			return(-1);
		}
		snag_start = new Date();
		if (fast_snag) {
			gold_start = me.getStat(D2JSP_STAT_GOLD);
			if ((puspec.distance_now > 8) || telekinesis_flag) {
				if (puspec.distance_now >= 20) {
					if (teleport_flag)
						D2JSP_SKILL_TeleportTo(this_obj.x, this_obj.y);
					else
						TDW_MOVE_MoveToObject(this_obj);
					delay(10);
					ISF_DoPickupItemBegin(this_obj);
					did_move  = true;
					this_move = true;
				}
				else {
					if (telekinesis_flag)
						ISF_TelekinesisOn(this_obj);
					else {
						TDW_MOVE_MoveToObject(this_obj);
						delay(10);
						ISF_DoPickupItemBegin(this_obj);
						did_move  = true;
						this_move = true;
					}
				}
			}
			else
				ISF_DoPickupItemBegin(this_obj);
			log_obj.logPickup("Snagging " + puspec.fullNameColor + ".");
			puspec.waitForPickup(1);
		}
		else {
			if (puspec.distance_now > 8) {
				if (teleport_flag)
					D2JSP_SKILL_TeleportTo(this_obj.x, this_obj.y);
				else
					TDW_MOVE_MoveToObject(this_obj);
				delay(10);
				did_move  = true;
				this_move = true;
			}
			if (isf_cfg && puspec.isf_flag)
				log_obj.logPickup("Snagging " +
					D2JSP_UTIL_FORMAT_LJust(puspec.fullNameColor,
					D2JSP_ITEM_COLORED_ITEM_NAME_MAX) + " ---> " +
					isf_cfg[ISF_COMPILED_DATA_SPEC_LIST]
					[puspec.other].sourceStringFromISF(isf_cfg));
			else
				log_obj.logPickup("Snagging " + puspec.fullNameColor);
		}
//		if (!puspec.code != "gld") {
		if (!fast_snag) {
			if (!will_fit_flag) {
				this_obj.interact(1);
				puspec.waitForPickup(10);
				while (!D2JSP_UTIL_GEN_CheckCursor())
					;
				log_obj.logFatal("Pickup list aborted because the " +
					"item picked up can not be moved to inventory for " +
					"lack of room --- item is on the cursor " +
					"(return_code = -2)");
				log_obj.flushLog();
				return(-2);
			}
			ISF_DoPickupItemBegin(this_obj);
//			this_obj.interact();
			var pickup_done = false;
			if (!(pickup_done = puspec.waitForPickup(10))) {
				log_obj.logWarning("The " + puspec.fullNameColor +
//					" is still on the ground after a full second.");
" is still on the ground after half a second (original mode = " +
	puspec.mode + " = " +
	D2JSP_MODE_UnitModeToName(D2JSP_UTIL_GETUNIT_ITEM, puspec.mode) + ").");
				ISF_DoPickupItemEnd(this_obj);
			}
			if (D2JSP_UTIL_GEN_CheckCursor(50, 10)) {
				log_obj.logFatal("Pickup list aborted because the " +
					"item picked up can not be moved from the cursor " +
					"to the inventory (return_code = -3)");
				log_obj.flushLog();
				return(-3);
			}
			if (!pickup_done) {
				delay(50);
				if (!puspec.waitForPickup(1)) {
					ISF_DoPickupItemBegin(this_obj);
					if (!puspec.waitForPickup(1)) {
						ISF_DoPickupItemEnd(this_obj);
						if (teleport_flag)
							D2JSP_SKILL_TeleportTo(this_obj.x, this_obj.y);
						else
							TDW_MOVE_MoveToObject(this_obj);
						delay(50);
						did_move  = true;
						this_move = true;
						ISF_DoPickupItemBegin(this_obj);
						puspec.waitForPickup(1);
					}
				}
				ISF_DoPickupItemEnd(this_obj);
			}
		}
		ISF_CB_InfoPickup.stage    = ISF_CB_INFO_STAGE_PICKUP_AFTER;
		if (count_1 < (pickup_list.length - 1)) {
			snag_time = (new Date()).valueOf() - snag_start.valueOf();
/*
			if (snag_time < (500 + (count_1 * 10)))
				D2JSP_UTIL_GEN_FuzzyDelay((500 + (count_1 * 10)) - snag_time);
print("***** SNAG DELAY = " + ((500 + (count_1 * 10)) - snag_time));
*/
		}
		if (callback_func && callback_func(ISF_CB_TYPE_PICKUP_ITEM,
			ISF_CB_InfoPickup, callback_data))
			break;
	}

	ISF_CB_InfoPickup.stage    = ISF_CB_INFO_STAGE_PICKUP_END;
	ISF_CB_InfoPickup.list     = pickup_list;
	ISF_CB_InfoPickup.index    = 0;
	ISF_CB_InfoPickup.item     = null;
	ISF_CB_InfoPickup.distance = 0;
	ISF_CB_InfoPickup.will_fit = false;
	if (callback_func)
		callback_func(ISF_CB_TYPE_PICKUP_ITEM, ISF_CB_InfoPickup, callback_data);

	if ((typeof(callback_func) == "function") ||
		(typeof(callback_func) == "string"))
		return_code = (typeof(callback_func) == "function") ?
			callback_func(callback_data) : eval(callback_func);

	if (did_move && (!(pickup_flags & ISF_PICKUP_FLAG_NO_RETURN))) {
		if (D2JSP_UTIL_GEN_TypeOfArrayIndexed(destination) &&
			(destination.length == 2) &&
			(typeof(destination[0]) == "number") &&
			(typeof(destination[1]) == "number") &&
			(D2JSP_SYLIB_DistPair([me.x, me.y], destination) <
			D2JSP_SYLIB_DistPair(original_location, destination)))
			did_move = false;
		if (did_move) {
			if (teleport_flag)
				D2JSP_SKILL_TeleportToPair(original_location);
			else
				TDW_MOVE_MoveToXYPair(original_location);
		}
	}

	if ((me.classid == D2JSP_CLASS_ID_SORCERESS) &&
		(left_skill != me.getSkill(0)))
		D2JSP_SKILL_SetSkill(left_skill, 0);

	if (log_obj.getLevelFile() <= D2JSP_UTIL_LOG_Level_MINUTIAE) {
		log_obj.logMinutiae("Pickup list done (return_code = " +
			return_code + ")");
		log_obj.flushLog();
	}

	runGC();

	return(return_code);
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
function ISF_DoPickupItemBegin(in_item)
{
	D2JSP_SKILL_WaitForIdle();

	if (parseFloat(me.version) < 0.33)
		in_item.interact();
	else
		clickMap(D2JSP_UTIL_CLICKMAP_TYPE_LEFT_DOWN,
			D2JSP_UTIL_CLICKMAP_SHIFT_OFF, in_item);
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
function ISF_DoPickupItemEnd(in_item)
{
	if (parseFloat(me.version) >= 0.33)
		clickMap(D2JSP_UTIL_CLICKMAP_TYPE_LEFT_UP,
			D2JSP_UTIL_CLICKMAP_SHIFT_OFF, in_item);
}
// ////////////////////////////////////////////////////////////////////////////

var ISF_LastChestPopUndoneCount = 0;
// ////////////////////////////////////////////////////////////////////////////
function ISF_DoChestPopBasic(max_distance, pop_flags, destination, max_count,
	callback_func, callback_data)
{
	var original_location = new Array(2);
	var callback_data     = new Array()
	var action_count      = 0;
	var telekinesis_flag  = false;
	var teleport_flag     = false;
	var did_move          = false;
	var results_data;
	var chest_list;
	var log_obj;
	var left_skill;
	var count_1;
	var this_obj;
	var this_parent;
	var this_distance;

	ISF_LastChestPopUndoneCount = 0;

	original_location[0] = me.x;
	original_location[1] = me.y;

	if ((!arguments.length) || (max_distance <= 0) || (max_distance > 40))
		max_distance = 20;

	if (arguments.length < 2)
		pop_flags = ISF_CHEST_FLAG_SPECIAL;

	if ((max_count == null) || (max_count <= 0))
		max_count = 99999;

	callback_data[0] = max_distance;
	callback_data[1] = pop_flags;
	callback_data[2] = new Array();

	results_data = D2JSP_OBJ_IterateObject(callback_data,
		ISF_DoChestPopBasic_Filter, D2JSP_OBJ_ActionContinue,
		null, D2JSP_MODE_OBJECT_IDLE);

	chest_list = results_data[D2JSP_OBJ_CALLBACK_DATA][2];

	if (!chest_list.length)
		return(0);

	chest_list.sort(ISF_DoChestPopBasic_Compare);

	log_obj = D2JSP_UTIL_LOG_GetALog();

/*
	if (me.classid == D2JSP_CLASS_ID_SORCERESS) {
		left_skill       = me.getSkill(0);
		telekinesis_flag = (me.getSkill(D2JSP_SKILL_TELEKINESIS, 0)) ? true :
			false;
		teleport_flag    = (me.getSkill(D2JSP_SKILL_TELEPORT, 0) &&
			(!D2JSP_AREA_IsTown())) ? true : false;
	}
*/

	left_skill       = me.getSkill(0);
	telekinesis_flag = D2JSP_SKILL_CanTelekinesisHere();
	teleport_flag    = D2JSP_SKILL_CanTeleportHere();

	for (count_1 = 0; count_1 < chest_list.length; count_1++) {
		if (max_count == count_1) {
			ISF_LastChestPopUndoneCount = chest_list.length - count_1;
			break;
		}
		var found_flag = false;
		this_obj = getUnit(D2JSP_UTIL_GETUNIT_OBJECT, chest_list[count_1][0],
			D2JSP_MODE_OBJECT_IDLE);
		if (this_obj) {
			do {
				this_parent = this_obj.getParent();
				if ((!this_parent) && (this_obj.mode == D2JSP_MODE_OBJECT_IDLE) &&
					(this_obj.x == chest_list[count_1][1]) &&
					(this_obj.y == chest_list[count_1][2])) {
					found_flag    = true;
					this_distance = Dist(me.x, me.y, this_obj.x, this_obj.y);
					if ((this_distance <= 5) && (!telekinesis_flag)) {
						log_obj.logMinutiae("CHEST POP: Popping " + this_obj.name +
							" (classid = " + this_obj.classid + ") at location [" +
							this_obj.x + ", " + this_obj.y +
							"] manually (my location is [" + me.x + ", " + me.y +
							"], distance = " + this_distance + "/" +
							chest_list[count_1][6] + ").");
						D2JSP_UTIL_InteractObject(this_obj);
					}
					else if (telekinesis_flag && (this_distance <= 20)) {
						log_obj.logMinutiae("CHEST POP: Popping " + this_obj.name +
							" (classid = " + this_obj.classid + ") at location [" +
							this_obj.x + ", " + this_obj.y +
							"] with telekinesis (my location is [" + me.x + ", " +
							me.y + "], distance = " + this_distance + "/" +
							chest_list[count_1][6] + ").");
						ISF_TelekinesisOn(this_obj);
					}
					else if (teleport_flag) {
						var start_location = [me.x, me.y];
						log_obj.logMinutiae("CHEST POP: Teleporting to " +
							this_obj.name + " at location [" + this_obj.x + ", " +
							this_obj.y + "] (my location is [" + me.x + ", " + me.y +
							"], distance = " + this_distance + "/" +
							chest_list[count_1][6] + ").");
						D2JSP_SKILL_TeleportTo(this_obj.x, this_obj.y);
						log_obj.logMinutiae("CHEST POP: Popping " + this_obj.name +
							" (classid = " + this_obj.classid + ") at location [" +
							this_obj.x + ", " + this_obj.y +
							"] with telekinesis (my location is [" + me.x + ", " +
							me.y + "], distance = " + this_distance + "/" +
							chest_list[count_1][6] + ").");
						ISF_TelekinesisOn(this_obj);
						D2JSP_SKILL_TeleportTo(start_location);
//						did_move = true;
					}
					else {
						log_obj.logMinutiae("CHEST POP: Moving to " +
							this_obj.name + " at location [" + this_obj.x + ", " +
							this_obj.y + "] (my location is [" + me.x + ", " + me.y +
							"], distance = " + this_distance + "/" +
							chest_list[count_1][6] + ").");
						TDW_MOVE_MoveToObject(this_obj);
						log_obj.logMinutiae("CHEST POP: Popping " + this_obj.name +
							" (classid = " + this_obj.classid + ") at location [" +
							this_obj.x + ", " + this_obj.y +
							"] manually (my location is [" + me.x + ", " + me.y +
							"], distance = " + this_distance + "/" +
							chest_list[count_1][6] + ").");
						D2JSP_UTIL_InteractObject(this_obj);
						did_move = true;
					}
					action_count++;
/*
log_obj.logInfo("CHEST POP: Popped " + this_obj.name + " (classid = " +
	this_obj.classid + ") at location [" + this_obj.x + ", " + this_obj.y +
	"], mode = " + this_obj.mode + "], distance = " + this_distance + "/" +
	chest_list[count_1][6] + ").");
*/
					break;
				}
			} while (this_obj && this_obj.getNext(chest_list[count_1][0],
				D2JSP_MODE_OBJECT_IDLE));
		}
		if (!found_flag)
			log_obj.logWarning("Unable to locate chest " +
				chest_list[count_1][3] + ", classid " + chest_list[count_1][4] +
				", at location [" + chest_list[count_1][1] + ", " +
				chest_list[count_1][2] + "] (my location is [" + me.x + ", " +
				me.y + "], orignal distance = " + chest_list[count_1][6] + ").");
		if ((typeof(callback_func) == "function") ||
			(typeof(callback_func) == "string")) {
			if ((return_code = ((typeof(callback_func) == "function") ?
				callback_func(callback_data) : eval(callback_func))) != 0)
				break;
		}
	}

	if (did_move) {
		if (D2JSP_UTIL_GEN_TypeOfArray(destination) && (destination.length == 2)&&
			(typeof(destination[0]) == "number") &&
			(typeof(destination[1]) == "number") &&
			(D2JSP_SYLIB_DistPair([me.x, me.y], destination) <
			D2JSP_SYLIB_DistPair(original_location, destination)))
			did_move = false;
		if (did_move) {
			log_obj.logMinutiae("CHEST POP: Returning to from [" +
				me.x + ", " + me.y + "] to original location at [" +
				original_location[0] + ", " + original_location[1] + "].");
			if (teleport_flag)
				D2JSP_SKILL_TeleportToPair(original_location);
			else
				TDW_MOVE_MoveToXYPair(original_location);
		}
	}

	if ((me.classid == D2JSP_CLASS_ID_SORCERESS) &&
		(left_skill != me.getSkill(0)))
		D2JSP_SKILL_SetSkill(left_skill, 0);

	return(action_count);
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
function ISF_DoChestPopBasic_Filter(this_obj, callback_data)
{
	var this_dist;

	if (ISF_IsChestDesirable(this_obj, callback_data[1]) &&
		((this_dist = Dist(me.x, me.y, this_obj.x, this_obj.y)) <=
		callback_data[0])) {
		callback_data[2].push([this_obj.code, this_obj.x, this_obj.y,
			this_obj.name, this_obj.classid, this_obj.mode, this_dist]);
		return(true);
	}
	else
		return(false);
		
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
function ISF_DoChestPopBasic_Compare(item_1, item_2)
{
	return((item_1[6] < item_2[6]) ? -1 : ((item_1[6] > item_2[6]) ? 1 : 0));
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
function ISF_DoOpenDoorsBasic(max_distance, destination, callback_func,
	callback_data)
{
	var original_location = new Array(2);
	var callback_data     = new Array()
	var action_count      = 0;
	var telekinesis_flag  = false;
	var teleport_flag     = false;
	var did_move          = false;
	var results_data;
	var door_list;
	var log_obj;
	var left_skill;
	var count_1;
	var this_obj;
	var this_parent;
	var this_distance;

	original_location[0] = me.x;
	original_location[1] = me.y;

	if ((!arguments.length) || (max_distance <= 0) || (max_distance > 40))
		max_distance = 20;

	callback_data[0] = max_distance;
	callback_data[1] = null;
	callback_data[2] = new Array();

	results_data = D2JSP_OBJ_IterateObject(callback_data,
		ISF_DoOpenDoorsBasic_Filter, D2JSP_OBJ_ActionContinue,
		"door", D2JSP_MODE_OBJECT_IDLE);

	door_list = results_data[D2JSP_OBJ_CALLBACK_DATA][2];

	if (!door_list.length)
		return(0);

	log_obj = D2JSP_UTIL_LOG_GetALog();

/*
	if (me.classid == D2JSP_CLASS_ID_SORCERESS) {
		left_skill       = me.getSkill(0);
		telekinesis_flag = (me.getSkill(D2JSP_SKILL_TELEKINESIS, 0)) ? true :
			false;
		teleport_flag    = (me.getSkill(D2JSP_SKILL_TELEPORT, 0) &&
			(!D2JSP_AREA_IsTown())) ? true : false;
	}
*/

	left_skill       = me.getSkill(0);
	telekinesis_flag = D2JSP_SKILL_CanTelekinesisHere();
	teleport_flag    = D2JSP_SKILL_CanTeleportHere();

	for (count_1 = 0; count_1 < door_list.length; count_1++) {
		var found_flag = false;
		this_obj = getUnit(D2JSP_UTIL_GETUNIT_OBJECT, door_list[count_1][0],
			D2JSP_MODE_OBJECT_IDLE);
		if (this_obj) {
			do {
				this_parent = this_obj.getParent();
				if ((!this_parent) && (this_obj.mode == D2JSP_MODE_OBJECT_IDLE) &&
					(this_obj.x == door_list[count_1][1]) &&
					(this_obj.y == door_list[count_1][2])) {
					found_flag    = true;
					this_distance = Dist(me.x, me.y, this_obj.x, this_obj.y);
					if ((this_distance <= 5) && (!telekinesis_flag)) {
						log_obj.logMinutiae("DOOR OPENING: Opening " + this_obj.name +
							" (classid = " + this_obj.classid + ") at location [" +
							this_obj.x + ", " + this_obj.y +
							"] manually (my location is [" + me.x + ", " + me.y +
							"], distance = " + this_distance + "/" +
							door_list[count_1][6] + ").");
						D2JSP_UTIL_InteractObject(this_obj);
					}
					else if (telekinesis_flag && (this_distance <= 20)) {
						log_obj.logMinutiae("DOOR OPENING: Opening " + this_obj.name +
							" (classid = " + this_obj.classid + ") at location [" +
							this_obj.x + ", " + this_obj.y +
							"] with telekinesis (my location is [" + me.x + ", " +
							me.y + "], distance = " + this_distance + "/" +
							door_list[count_1][6] + ").");
						ISF_TelekinesisOn(this_obj);
					}
					else if (teleport_flag) {
						var start_location = [me.x, me.y];
						log_obj.logMinutiae("DOOR OPENING: Teleporting to " +
							this_obj.name + " at location [" + this_obj.x + ", " +
							this_obj.y + "] (my location is [" + me.x + ", " + me.y +
							"], distance = " + this_distance + "/" +
							door_list[count_1][6] + ").");
						D2JSP_SKILL_TeleportTo(this_obj.x, this_obj.y);
						log_obj.logMinutiae("DOOR OPENING: Opening " + this_obj.name +
							" (classid = " + this_obj.classid + ") at location [" +
							this_obj.x + ", " + this_obj.y +
							"] with telekinesis (my location is [" + me.x + ", " +
							me.y + "], distance = " + this_distance + "/" +
							door_list[count_1][6] + ").");
						ISF_TelekinesisOn(this_obj);
						D2JSP_SKILL_TeleportTo(start_location);
//						did_move = true;
					}
					else {
						log_obj.logMinutiae("DOOR OPENING: Moving to " +
							this_obj.name + " at location [" + this_obj.x + ", " +
							this_obj.y + "] (my location is [" + me.x + ", " + me.y +
							"], distance = " + this_distance + "/" +
							door_list[count_1][6] + ").");
						TDW_MOVE_MoveToObject(this_obj);
						log_obj.logMinutiae("DOOR OPENING: Opening " + this_obj.name +
							" (classid = " + this_obj.classid + ") at location [" +
							this_obj.x + ", " + this_obj.y +
							"] manually (my location is [" + me.x + ", " + me.y +
							"], distance = " + this_distance + "/" +
							door_list[count_1][6] + ").");
						D2JSP_UTIL_InteractObject(this_obj);
						did_move = true;
					}
					action_count++;
/*
log_obj.logInfo("DOOR OPENING: Opened " + this_obj.name + " (classid = " +
	this_obj.classid + ") at location [" + this_obj.x + ", " + this_obj.y +
	"], mode = " + this_obj.mode + "], distance = " + this_distance + "/" +
	door_list[count_1][6] + ").");
*/
					break;
				}
			} while (this_obj && this_obj.getNext(door_list[count_1][0],
				D2JSP_MODE_OBJECT_IDLE));
		}
		if (!found_flag)
			log_obj.logWarning("Unable to locate door " +
				door_list[count_1][3] + ", classid " + door_list[count_1][4] +
				", at location [" + door_list[count_1][1] + ", " +
				door_list[count_1][2] + "] (my location is [" + me.x + ", " +
				me.y + "], orignal distance = " + door_list[count_1][6] + ").");
		if ((typeof(callback_func) == "function") ||
			(typeof(callback_func) == "string")) {
			if ((return_code = ((typeof(callback_func) == "function") ?
				callback_func(callback_data) : eval(callback_func))) != 0)
				break;
		}
	}

	if (did_move) {
		if (D2JSP_UTIL_GEN_TypeOfArray(destination) && (destination.length == 2)&&
			(typeof(destination[0]) == "number") &&
			(typeof(destination[1]) == "number") &&
			(D2JSP_SYLIB_DistPair([me.x, me.y], destination) <
			D2JSP_SYLIB_DistPair(original_location, destination)))
			did_move = false;
		if (did_move) {
			log_obj.logMinutiae("DOOR OPENING: Returning to from [" +
				me.x + ", " + me.y + "] to original location at [" +
				original_location[0] + ", " + original_location[1] + "].");
			if (teleport_flag)
				D2JSP_SKILL_TeleportToPair(original_location);
			else
				TDW_MOVE_MoveToXYPair(original_location);
		}
	}

	if ((me.classid == D2JSP_CLASS_ID_SORCERESS) &&
		(left_skill != me.getSkill(0)))
		D2JSP_SKILL_SetSkill(left_skill, 0);

	return(action_count);
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
function ISF_DoOpenDoorsBasic_Filter(this_obj, callback_data)
{
	var this_dist;

	if ((this_obj.name.toLowerCase() == "door") &&
		(this_obj.mode == D2JSP_MODE_OBJECT_IDLE) &&
		((this_dist = Dist(me.x, me.y, this_obj.x, this_obj.y)) <=
		callback_data[0])) {
		callback_data[2].push([this_obj.code, this_obj.x, this_obj.y,
			this_obj.name, this_obj.classid, this_obj.mode, this_dist]);
		return(true);
	}
	else
		return(false);
		
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
function ISF_TelekinesisOn(this_obj)
{
	return(D2JSP_SKILL_TelekinesisOn(this_obj));
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
function ISF_TelekinesisOnFast(this_obj)
{
	return(D2JSP_SKILL_TelekinesisOnFast(this_obj));
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
var ISF_CfgDefaultDir          = "settings"
var ISF_CfgDefaultFileISF      = ISF_CfgDefaultDir + "/ISF"
var ISF_CfgDefaultFileISF_SELL = ISF_CfgDefaultFileISF + ".SELL"
var ISF_CfgDefaultFileISF_SHOP = ISF_CfgDefaultFileISF + ".SHOP"
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
function ISF_GetCfgFileNameISF(suffix)
{
	return(ISF_GetCfgFileName(ISF_CfgDefaultFileISF, suffix));
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
function ISF_GetCfgFileNameISFSell(suffix)
{
	return(ISF_GetCfgFileName(ISF_CfgDefaultFileISF_SELL, suffix));
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
function ISF_GetCfgFileNameISFShop(suffix)
{
	return(ISF_GetCfgFileName(ISF_CfgDefaultFileISF_SHOP, suffix));
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
function ISF_GetCfgFileName(prefix, suffix)
{
	var isf_file_name;

	prefix = prefix.replace(/\\+/g, "/");
	prefix = prefix.replace(/\/+/g, "/");
	prefix = prefix.replace(/^\s+|\s+$/g, "");

	if ((isf_file_name = ISF_GetCfgFileNameBasic(prefix, suffix)) != null)
		return(isf_file_name);

print("PREFIX = [" + prefix + "]");
	return((prefix.toLowerCase != ISF_CfgDefaultFileISF.toLowerCase()) ?
		ISF_GetCfgFileName(ISF_CfgDefaultFileISF, suffix) : null);
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
function ISF_GetCfgFileNameBasic(prefix, suffix, realm, account, name)
{
	prefix  = prefix.replace(/\\+/g, "/");
	prefix  = prefix.replace(/\/+/g, "/");
	prefix  = prefix.replace(/^\s+|\s+$/g, "");
	prefix  = (D2JSP_UTIL_GEN_TypeOfStringNotEmpty(prefix))  ? prefix  :
		ISF_CfgDefaultFileISF;
	suffix  = (D2JSP_UTIL_GEN_TypeOfStringNotEmpty(suffix))  ? suffix  : null;
	realm   = (D2JSP_UTIL_GEN_TypeOfStringNotEmpty(realm))   ? realm   :
		((D2JSP_UTIL_GEN_TypeOfStringNotEmpty(me.realm)) ? me.realm : "#SP#");
	account = (D2JSP_UTIL_GEN_TypeOfStringNotEmpty(account)) ? account :
		((D2JSP_UTIL_GEN_TypeOfStringNotEmpty(me.account)) ? me.account : "#SP#");
	name    = (D2JSP_UTIL_GEN_TypeOfStringNotEmpty(name))    ? name    : me.name;

	var portion_list = [suffix, realm, account, name];
	var tmp_file_name;

	if (suffix == null)
		portion_list.shift();

/*
	while (portion_list.length) {
		tmp_file_name = prefix;
		for (var count_1 = 0; count_1 < portion_list.length; count_1++)
			tmp_file_name += "." + portion_list[count_1];
		tmp_file_name += ".cfg";
print("***** CHECKING [" + tmp_file_name + "]");
		if (D2JSP_UTIL_GEN_FileExists(tmp_file_name))
			return(tmp_file_name);
		portion_list.pop();
	}

	tmp_file_name = prefix + ".cfg";

	return((D2JSP_UTIL_GEN_FileExists(tmp_file_name)) ? tmp_file_name : null);
*/

	var portion_count = portion_list.length + 1;
	for (var count_1 = 0; count_1 < portion_count; count_1++) {
		tmp_file_name = prefix + ((portion_list.length) ? "." : "") +
			portion_list.join(".") + ".cfg";
//print("***** CHECKING [" + tmp_file_name + "]");
		if (D2JSP_UTIL_GEN_FileExists(tmp_file_name))
			return(tmp_file_name);
		portion_list.pop();
	}

//print("Stopping"); stop();

	return((suffix != null) ?
		ISF_GetCfgFileNameBasic(prefix, null, realm, account, name) : null);
}
// ////////////////////////////////////////////////////////////////////////////

// Compiles a parsed ISF into the internal representation.
// ////////////////////////////////////////////////////////////////////////////
function ISF_CompileConfig(in_source, in_flags, error_list, parse_cfg,
	isf_cfg, src_list)
{
	var priority_hash  = new Array();
	var priority_list  = new Array();
	var code_hash      = new Array();
	var eval_index     = ISF_COMPILED_DATA_EVAL;
	var id_index       = ISF_COMPILED_DATA_ID;
	var this_code;
	var this_prior;
	var count_1;
	var count_2;
	var count_3;
	var count_4;
	var code_array;
	var this_spec;
	var this_ispec;
	var this_type;
	var this_code;
	var this_eval;

	isf_cfg.length = 0;

	isf_cfg[ISF_COMPILED_DATA_VERSION]   = ISF_VERSION_NUMBER;
	isf_cfg[ISF_COMPILED_DATA_SOURCE]    = D2JSP_UTIL_GEN_CloneObject(in_source);
	isf_cfg[ISF_COMPILED_DATA_DATE]      = new Date();
	isf_cfg[ISF_COMPILED_DATA_CHECKSUM]  = "CHECKSUM NOT IMPLEMENTED";
	isf_cfg[ISF_COMPILED_DATA_SRC_LIST]  = D2JSP_UTIL_GEN_CloneObject(src_list);
	isf_cfg[ISF_COMPILED_DATA_SPEC_LIST] = D2JSP_UTIL_GEN_CloneObject(parse_cfg);

	//	CODE NOTE: Here remove identical specifications.

	// CODE NOTE: Here remove the lower priority specifications of
	// specifications which differ only in their priority ordering.

	// ///////////////////////////////////////////////////////////////////
	// ///////////////////////////////////////////////////////////////////
	// Get priority information into a handy form...
	// ///////////////////////////////////////////////////////////////////
	//		1) First, get a unique list of all of the priorities...
	for (count_1 = 0; count_1 < parse_cfg.length; count_1++)
		priority_hash[parse_cfg[count_1].ispec_list[0].item_priority + ""] =
			parse_cfg[count_1].ispec_list[0].item_priority;
	//		2) Next, put them into an array...
	for (this_prop in priority_hash)
		priority_list.push(parseInt(priority_hash[this_prop], 10));
	//		3) Sort that array. Priorities are now ordered...
	priority_list.sort();
	//		4) Finally, set the value of the priority hash to the array index.
	for (count_1 = 0; count_1 < priority_list.length; count_1++)
		priority_hash[priority_list[count_1] + ""] = count_1;
	// ///////////////////////////////////////////////////////////////////

	isf_cfg[ISF_COMPILED_DATA_PRIORITY]  = new Array(priority_list.length);
	isf_cfg[ISF_COMPILED_DATA_PICKUP]    = new Array(priority_list.length);
	isf_cfg[ISF_COMPILED_DATA_ID]        = new Array();
	isf_cfg[ISF_COMPILED_DATA_EVAL]      = new Array(priority_list.length);

	for (count_1 = 0; count_1 < priority_list.length; count_1++)
		isf_cfg[ISF_COMPILED_DATA_PRIORITY][count_1] = priority_list[count_1];

	if (!(return_code = ISF_CompileAConfig(ISF_COMPILED_DATA_EVAL,
		priority_list, parse_cfg, isf_cfg))) {
		// Modify the list compiled specifications to build a list which includes
		// only those qualifiers known without identifying the item. We'll use
		// this modified list to compile the pickup specification...
		for (count_1 = 0; count_1 < parse_cfg.length; count_1++) {
			this_spec = parse_cfg[count_1];
			if (this_spec.known_unided != true) {
				for (count_2 = 0; count_2 < this_spec.qspec_list.length; ) {
					if (ISF_QualTypeIsKnownUnided(this_spec.qspec_list[count_2].
						qual_type))
						count_2++;
					else
						this_spec.qspec_list.splice(count_2, 1);
				}
			}
		}
		return_code = ISF_CompileAConfig(ISF_COMPILED_DATA_PICKUP,
			priority_list, parse_cfg, isf_cfg)
	}

	if (!return_code) {
		// Build the hashed array keyed by item codes. The value of each is
		// an array of indices into the specification array.
		for (this_prior = 0; this_prior < isf_cfg[eval_index].length;
			this_prior++) {
			for (this_code in isf_cfg[eval_index][this_prior]) {
				for (count_1 = 0;
					count_1 < isf_cfg[eval_index][this_prior][this_code].length;
					count_1++) {
					if (typeof(isf_cfg[id_index][this_code]) == "undefined")
						isf_cfg[id_index][this_code] = new Array();
					isf_cfg[id_index][this_code].push(isf_cfg[eval_index]
						[this_prior][this_code][count_1][0]);
				}
			}
		}
	}

//	D2JSP_UTIL_GEN_GCDelay();
	runGC();

	return(return_code);
}
// ////////////////////////////////////////////////////////////////////////////

// Compiles a parsed ISF into the internal representation.
// ////////////////////////////////////////////////////////////////////////////
function ISF_CompileAConfig(isf_index, priority_list, parse_cfg, isf_cfg)
{
	var code_hash = new Array();
	var count_1;
	var count_2;
	var count_3;
	var count_4;
	var code_array;
	var this_spec;
	var this_ispec;
	var this_type;
	var this_code;
	var this_eval;

	// ///////////////////////////////////////////////////////////////////
	for (count_1 = 0; count_1 < priority_list.length; count_1++) {
		isf_cfg[isf_index][count_1] = new Array();
		code_array = new Array(ISF_ITEM_NAME_TYPE_COUNT);
		for (count_2 = 0; count_2 < ISF_ITEM_NAME_TYPE_COUNT; count_2++)
			code_array[count_2] = new Array();
		for (count_2 = 0; count_2 < parse_cfg.length; count_2++) {
			if (parse_cfg[count_1].ispec_list[0].item_priority !=
				priority_list[count_1])
				continue;
			this_spec  = parse_cfg[count_2];
			for (count_3 = 0; count_3 < this_spec.ispec_list.length; count_3++) {
				this_ispec = this_spec.ispec_list[count_3];
				this_type  = this_ispec.item_type;
				this_code  = this_ispec.item_name;
				this_eval  = [count_2, ISF_CompileEval(this_spec.qspec_list)];
				if (this_type == ISF_ITEM_NAME_TYPE_ITEMNAME) {
print("Item names not yet supported.");
					continue;
				}
				else if (this_type == ISF_ITEM_NAME_TYPE_ITEMCODE) {
					if (typeof(code_array[this_type][this_code]) == "undefined")
						code_array[this_type][this_code] = new Array();
					code_array[this_type][this_code].push(this_eval);
					continue;
				}
				else if (this_type == ISF_ITEM_NAME_TYPE_ITEMTYPE) {
					for (count_4 = 0;
						count_4 < D2JSP_ITEM_ItemTypeList[this_code].length;
						count_4++) {
						var tmp_code = D2JSP_ITEM_ItemTypeList[this_code][count_4];
						if (typeof(code_array[this_type][tmp_code]) == "undefined")
							code_array[this_type][tmp_code] = new Array();
						code_array[this_type][tmp_code].push(this_eval);
					}
				}
				else if (this_type == ISF_ITEM_NAME_TYPE_ITEMCATEGORY) {
					var cate_number = D2JSP_ITEM_CategoryParseToNumber(this_code);
					for (count_4 = 0;
						count_4 < D2JSP_ITEM_CategoryToCodeList[cate_number].length;
						count_4++) {
						var tmp_code = D2JSP_ITEM_CategoryToCodeList[cate_number][count_4];
						if (typeof(code_array[this_type][tmp_code]) == "undefined")
							code_array[this_type][tmp_code] = new Array();
						code_array[this_type][tmp_code].push(this_eval);
					}
				}
			}
		}
		for (count_2 = 0; count_2 < ISF_ITEM_NAME_TYPE_COUNT; count_2++) {
			for (this_prop in code_array[count_2]) {
				if (typeof(isf_cfg[isf_index][count_1][this_prop])
					== "undefined")
					isf_cfg[isf_index][count_1][this_prop] =
						new Array();
				isf_cfg[isf_index][count_1][this_prop] =
					isf_cfg[isf_index][count_1][this_prop].
					concat(code_array[count_2][this_prop]);
			}
		}
	}
	// ///////////////////////////////////////////////////////////////////

//	D2JSP_UTIL_GEN_GCDelay();

	return(0);
}
// ////////////////////////////////////////////////////////////////////////////

// Compiles an ISF QSpec into its equivalent Javascript 'eval()' string.
// ////////////////////////////////////////////////////////////////////////////
function ISF_CompileEval(qspec_list)
{
	var out_string = "";
	var count_1;

	for (count_1 = 0; count_1 < qspec_list.length; count_1++)
		out_string += ((count_1) ? " && " : "") + qspec_list[count_1];

	return(out_string);
}
// ////////////////////////////////////////////////////////////////////////////

// Parses the specified file into an array of ISF specifiers.
// ////////////////////////////////////////////////////////////////////////////
function ISF_PARSE_ParseFile(in_source, inc_list, in_flags, error_list,
	parse_cfg, src_list)
{
	var return_code      = 0;
	var stack_added_flag = false;
	var cfg_line_list    = new Array();
	var file_handle;

	in_source  = in_source.replace(/\\+/g, "/");
	in_source  = in_source.replace(/\/+/g, "/");
	in_source  = in_source.replace(/^\s+|\s+$/g, "");
	inc_list   = (inc_list   instanceof Array) ? inc_list   : (new Array());
	error_list = (error_list instanceof Array) ? error_list : (new Array());
	parse_cfg  = (parse_cfg  instanceof Array) ? parse_cfg  : (new Array());
	src_list   = (src_list   instanceof Array) ? src_list   : (new Array());

	if ((!D2JSP_UTIL_GEN_TypeOfString(in_source)) || (in_source == "")) {
		if (error_list instanceof Array)
			error_list.push("Invalid configuration file name specified " +
				"(configuration file name is empty).");
		return_code = -2;
	}
	else if (!(file_handle = fileOpen(in_source, 0))) {
		error_list.push("Attempt to open file '" + in_source +
			"' for reading failed.");
		return_code = -2;
	}
	else {
		inc_list[in_source.toLowerCase()] = true;
		stack_added_flag                  = true;
		while (!file_handle.eof)
			cfg_line_list.push(file_handle.readLine());
		file_handle.close();
		return_code = ISF_PARSE_ParseList(in_source, cfg_line_list,
			inc_list, in_flags, error_list, parse_cfg, src_list);
	}

	if (stack_added_flag)
		inc_list[in_source.toLowerCase()] = false;

	return(return_code);
}
// ////////////////////////////////////////////////////////////////////////////

// Parses the specified array of strings into an array of ISF specifiers.
// ////////////////////////////////////////////////////////////////////////////
function ISF_PARSE_ParseList(in_source, cfg_line_list, inc_list,
	in_flags, error_list, parse_cfg, src_list)
{
	var return_code = 0;
	var count_1;
	var count_2;
	var inc_name;
	var parse_result;

	in_source  = ((typeof(in_source) != "string") || (in_source == "")) ?
		ISF_INTERNAL_SOURCE_NAME : in_source;
	inc_list   = (inc_list   instanceof Array) ? inc_list   : (new Array());
	error_list = (error_list instanceof Array) ? error_list : (new Array());
	parse_cfg  = (parse_cfg  instanceof Array) ? parse_cfg  : (new Array());
	src_list   = (src_list   instanceof Array) ? src_list   : (new Array());

	src_list.push(in_source);

	for (count_1 = 0; count_1 < cfg_line_list.length; count_1++) {
		inc_name = cfg_line_list[count_1].match(/^\s*include\s+\"(.+)\"\s*$/i);
		if (inc_name && (inc_name.length == 2)) {
			inc_name[1] = inc_name[1].replace(/\\+/g, "/");
			inc_name[1] = inc_name[1].replace(/\/+/g, "/");
			inc_name[1] = inc_name[1].replace(/^\s+|\s+$/g, "");
			if ((typeof(inc_list[inc_name[1].toLowerCase()]) != "undefined") &&
				(inc_list[inc_name[1].toLowerCase()] == true)) {
				error_list.push("Error on line " + (count_1 + 1) + " of file '" +
					in_source + "': " + "File '" + inc_name[1] +
					"' may not be included recursively.");
				return_code = -1;
			}
			else if ((return_code = ISF_PARSE_ParseFile(inc_name[1], inc_list,
				in_flags, error_list, parse_cfg))) {
				if (return_code == -2)
					error_list[error_list.length - 1] = "Error on line " +
						(count_1 + 1) + " of file '" + in_source + "': " +
						error_list[error_list.length - 1];
				return_code = -1;
			}
			if (return_code && (!(in_flags & ISF_PARSE_FLAG_CONTINUE_ON_ERROR)))
				break;
		}
		else {
			parse_result = ISF_PARSE_ParseLine(cfg_line_list[count_1],
				0, in_source, count_1 + 1);
			if (parse_result[0] < 0) {
				error_list.push("Error on line " + (count_1 + 1) + " of file '" +
					in_source + "': " + parse_result[1]);
				return_code = -1;
				if (!(in_flags & ISF_PARSE_FLAG_CONTINUE_ON_ERROR))
					break;
			}
			else if (parse_result[0] == 1)
				parse_cfg.push(new ISF_Specifier(src_list.length - 1,
					count_1 + 1, parse_result[1][0], parse_result[1][1]));
		}
//		if (!(count_1 % 100))
//			D2JSP_UTIL_GEN_GCDelay();
	}

//	D2JSP_UTIL_GEN_GCDelay();

	return(return_code);
}
// ////////////////////////////////////////////////////////////////////////////

// Parses a single string into its component ISF ISpec and QSpec.
// ////////////////////////////////////////////////////////////////////////////
function ISF_PARSE_ParseLine(in_line)
{
	var this_line     = D2JSP_UTIL_FORMAT_RTrim(in_line);
	var this_length   = this_line.length;
	var current_pos   = 0;
	var item_code     = "";
	var ispec_list    = new Array();
	var token_array   = new Array();
	var this_priority = ISF_SPEC_ITEM_PRIORITY_MAX_ITEM;
	var token_start;
	var token_end;
	var this_token;
	var parsed_token;

	// Not interested in leading white space...
	while ((current_pos < this_length) &&
		((this_line.charAt(current_pos) == " ") ||
		(this_line.charAt(current_pos) == '\t')))
		current_pos++;

	// Or in comments...
	if ((current_pos >= this_length) ||
		(this_line.charAt(current_pos) == ";"))
		return([0]);

	// Can't allow any of these characters in the item specification as they
	// Might interfere with use of 'eval()'...
	if ((token_start = this_line.indexOf("\\", current_pos)) > -1)
		return([-1, "Invalid character in item specifier at character position " + 
			(current_pos + token_start + 1)]);
	else if ((token_start = this_line.indexOf("\"", current_pos)) > -1)
		return([-1, "Invalid character in item specifier at character position " + 
			(current_pos + token_start + 1)]);
/*
	CODE NOTE: We need apostrophes for such things as 'Jeweler's' prefix.
	else if ((token_start = this_line.indexOf("\'", current_pos)) > -1)
		return([-1, "Invalid character in item specifier at character position " + 
			(current_pos + token_start + 1)]);
*/

	while (current_pos < this_length) {
		var this_char = this_line.charAt(current_pos);
		if ((this_char == " ") || (this_char == '\t'))
			current_pos++;
		else if (this_char == ":")
			return([-1, "Unexpected qualifier separator at character position " + 
				(current_pos + 1)]);
		else {
			token_start = current_pos;
			token_end   = (this_line.indexOf(":", current_pos) > -1) ?
				this_line.indexOf(":", current_pos) : this_length;
			this_token  = this_line.substring(token_start, token_end);
			if (!ispec_list.length) {		// Must be an item specifier
				parsed_token = ISF_PARSE_ParseISpec(null, this_token);
				if (parsed_token[0])
					return([-1, "Invalid item specifier beginning at character " +
						"position " + (token_start + 1) + ": " + parsed_token[1]]);
				ispec_list = parsed_token[1];
			}
			else {								// Otherwise, a qualifier
				parsed_token = ISF_PARSE_ParseQSpec(this_token);
				if (parsed_token[0])
					return([-1, "Invalid qualifier beginning at character position "+
						(token_start + 1) + ": " + parsed_token[1]]);
				token_array.push(parsed_token[1]);
			}
			current_pos = token_end + 1;
		}
	}

	if (!ispec_list.length)
		return([-1, "Empty item code/name specified."]);

	// CODE NOTE: Here remove identical qualifiers.
	//					6lw:quality=unique:quality=unique

	// CODE NOTE: Here remove remove redundant qualifiers
	//					6lw:quality>set:quality=unique
	//					Windforce:quality=unique
	//					6lw:itemclass=elite				; 6lw is an elite item

	// CODE NOTE: Here check for conflicting qualifiers
	//					6lw:quality=set:quality=unique
	//					Windforce:quality=set			; Windforce is unique
	//					Windforce:itemclass=normal		; Windforce is elite

	return([1, [ispec_list, token_array]]);
}
// ////////////////////////////////////////////////////////////////////////////

// Parses a string into an array ISF ISpecs.
// ////////////////////////////////////////////////////////////////////////////
function ISF_PARSE_ParseISpec(item_priority, in_token)
{
	var this_token = D2JSP_UTIL_FORMAT_RTrim(in_token);
	var token_list = new Array();
	var ispec_list = new Array();
	var count_1;
	var count_2;
	var this_token;
	var item_type;
	var item_name;
	var tmp_name;

	token_list = this_token.split(",");

	for (count_1 = 0; count_1 < token_list.length; count_1++) {
		this_token =
			D2JSP_UTIL_FORMAT_OneSpace(D2JSP_UTIL_FORMAT_Trim(token_list[count_1]));
		if (this_token == "")
			return([-1, "Empty item specifier encountered."]);
		if (D2JSP_ITEM_IsValidCode(this_token.toLowerCase())) {
			item_type = ISF_ITEM_NAME_TYPE_ITEMCODE;
			item_name = this_token.toLowerCase();
		}
		else if (D2JSP_ITEM_NameToCode(this_token.toLowerCase()) != null) {
			item_type = ISF_ITEM_NAME_TYPE_ITEMCODE;
			item_name = D2JSP_ITEM_NameToCode(this_token);
		}
		else if ((tmp_name = this_token.match(/^TYPE\s+(.+)$/i)) != null) {
			tmp_name[1] =
				D2JSP_UTIL_FORMAT_OneSpace(D2JSP_UTIL_FORMAT_Trim(tmp_name[1]));
			if (tmp_name && D2JSP_ITEMTYPE_NameIsValid(tmp_name[1])) {
				item_type = ISF_ITEM_NAME_TYPE_ITEMTYPE;
				item_name = tmp_name[1].toLowerCase();
			}
			else if (tmp_name && D2JSP_ITEMTYPE_TextIsValid(tmp_name[1])) {
				item_type = ISF_ITEM_NAME_TYPE_ITEMTYPE;
				item_name = D2JSP_ITEMTYPE_TextToName(tmp_name[1]).toLowerCase();
			}
			else
				return([-1, "Unable to resolve the item type specifier '" +
					this_token + "'"]);
		}
		else if ((tmp_name = this_token.match(/^CATEGORY\s+(.+)$/i)) != null) {
			tmp_name[1] =
				D2JSP_UTIL_FORMAT_OneSpace(D2JSP_UTIL_FORMAT_Trim(tmp_name[1]));
			if (tmp_name && (D2JSP_ITEM_CategoryParseToNumber(tmp_name[1]) != -1)){
				item_type = ISF_ITEM_NAME_TYPE_ITEMCATEGORY;
				item_name = tmp_name[1];
			}
			else
				return([-1, "Unable to resolve the item category specifier '" +
					this_token + "'"]);
		}
		else
			return([-1, "Unable to resolve the item specifier '" +
				this_token + "'"]);
		ispec_list.push(new ISF_ISpec(item_priority, item_type, item_name));
	}

	if (!ispec_list.length)
		return([-1, "Empty item specifier encountered."]);

	return([0, ispec_list]);
}
// ////////////////////////////////////////////////////////////////////////////

// Parses a string representing an ISF QSpec into its component parts.
// ////////////////////////////////////////////////////////////////////////////
function ISF_PARSE_ParseQSpec(in_token)
{
	var this_token = D2JSP_UTIL_FORMAT_RTrim(in_token);
	var pos_eq     = this_token.indexOf("=");
	var pos_ne     = this_token.indexOf("!");
	var pos_lt     = this_token.indexOf("<");
	var pos_gt     = this_token.indexOf(">");
	var op_count;
	var pos_op;
	var qual_type;
	var qual_name;
	var qual_other;
	var qual_op;
	var qual_value;

	// Let's be perfectly clear here...
	op_count =  ((pos_eq == -1) ? 0 : 1) + ((pos_ne == -1) ? 0 : 1) +
					((pos_lt == -1) ? 0 : 1) + ((pos_gt == -1) ? 0 : 1);

	if (op_count > 1)
		return([-1, "Multiple conditional operators found in qualifier '" +
			this_token + "' (" + op_count +
			"conditional operators were found, one was expected)."]);
	else if (op_count == 0)
		return([-1, "No conditional operator was found in qualifier '" +
			this_token + "'."]);

	pos_op = Math.max(pos_eq, Math.max(Math.max(pos_ne, pos_lt), pos_gt));

	if (!pos_op)
		return([-1, "Conditional operator found at the beginning of qualifier '" +
			this_token + "'"]);

	if (pos_op == (this_token.length - 1))
		return([-1, "Conditional operator found at the end of qualifier '" +
			this_token + "'"]);

	qual_name  = D2JSP_UTIL_FORMAT_OneSpace(D2JSP_UTIL_FORMAT_Trim(
		this_token.substr(0, pos_op)));
	qual_op    = D2JSP_UTIL_FORMAT_OneSpace(D2JSP_UTIL_FORMAT_Trim(
		this_token.substr(pos_op, 1)));
	qual_value = D2JSP_UTIL_FORMAT_OneSpace(D2JSP_UTIL_FORMAT_Trim(
		this_token.substr(pos_op + 1)));

	var return_data;

	if ((return_data = ISF_PARSE_ParseQSpecName(qual_name))[0])
		return(return_data);

	qual_type  = return_data[1][0];
	qual_name  = return_data[1][1];
	qual_other = return_data[1][2];

	if ((return_data = ISF_PARSE_ParseQSpecOp(qual_op))[0])
		return(return_data);

	qual_op = return_data[1];

	if ((return_data = ISF_PARSE_ParseQSpecValue(qual_type,
		qual_value))[0])
		return(return_data);

	qual_value = return_data[1];

	return([0, new ISF_QSpec(qual_type, qual_name, qual_op, qual_value, qual_other)]);
}
// ////////////////////////////////////////////////////////////////////////////

// Parses an ISF QSpec name (left side of an ISF expression).
// ////////////////////////////////////////////////////////////////////////////
function ISF_PARSE_ParseQSpecName(qual_name)
{
	var qual_type;
	var stat_value;
	var skill_value;

	qual_name = D2JSP_UTIL_FORMAT_OneSpace(D2JSP_UTIL_FORMAT_RTrim(qual_name));

	if (D2JSP_UTIL_FORMAT_IsDigit(qual_name)) {
		if ((parseInt(qual_name, 10) < D2JSP_STAT_MINIMUM) ||
			(parseInt(qual_name, 10) > D2JSP_STAT_MAXIMUM))
			return([-1, "Invalid qualifier name ('" + qual_name + "') specified" +
				"as a STAT number --- valid numbers range from " +
				D2JSP_STAT_MINIMUM + " to " + D2JSP_STAT_MAXIMUM +
				", inclusive."]);
		return([0, [ISF_QUAL_NAME_TYPE_STAT, parseInt(qual_name, 10), null]]);
	}
	else if ((stat_value = ISF_PARSE_ParseQSpecNameStatExtended(qual_name)) != null)
		return([0, [ISF_QUAL_NAME_TYPE_STAT_EXTENDED, 0, stat_value]]);
	else if ((stat_value = D2JSP_STAT_NameToStat(qual_name)) != -1)
		return([0, [ISF_QUAL_NAME_TYPE_STAT, stat_value, null]]);
	else if ((skill_value = ISF_PARSE_ParseQSpecNameSkill(qual_name)) != null)
		return([0, skill_value]);
	else if ((qual_type = ISF_QualTypeNameToType(qual_name)) != -1)
		return([0, [qual_type, 0, null]]);
	else if (D2JSP_ITEMFLAG_ItemFlagParseToNumber(qual_name) != -1)
		return([0, [ISF_QUAL_NAME_TYPE_ITEMFLAG,
			D2JSP_ITEMFLAG_ItemFlagParseToName(qual_name), null]]);

	return([-1, "Invalid qualifier name ('" + qual_name + "') specified"]);
}
// ////////////////////////////////////////////////////////////////////////////

// Parses an ISF QSpec operator (middle of an ISF expression).
// ////////////////////////////////////////////////////////////////////////////
function ISF_PARSE_ParseQSpecOp(qual_op)
{
	return(("=!<>".indexOf(qual_op) > -1) ? [0, qual_op] :
		[-1, "Invalid qualifer operator ('" + qual_op + "')."]);
}
// ////////////////////////////////////////////////////////////////////////////

// Parses an ISF QSpec value (right side of an ISF expression).
// ////////////////////////////////////////////////////////////////////////////
function ISF_PARSE_ParseQSpecValue(qual_type, qual_value)
{
	var is_integer;
	var is_digit;
	var integer_value;
	var this_value;

	if ((is_integer = D2JSP_UTIL_FORMAT_IsInteger(qual_value))) {
		is_digit      = D2JSP_UTIL_FORMAT_IsDigit(qual_value);
		integer_value = parseInt(qual_value);
	}

	switch (qual_type) {
		case ISF_QUAL_NAME_TYPE_STAT				:
			if (is_integer)
				return([0, integer_value]);
			return([-1, "Invalid stat value specified ('" + qual_value + "') -- " +
				"an integer value was expected."]);
			break;
		case ISF_QUAL_NAME_TYPE_QUALITY			:
			if (is_digit) {
				if (integer_value == D2JSP_ITEM_QUALITY_NONE)
					return([-1, "A quality value of none (0) cannot be specified."]);
				else if ((integer_value >= D2JSP_ITEM_QUALITY_LOW_QUALITY) &&
					(integer_value <= D2JSP_ITEM_QUALITY_MAXIMUM))
					return([0, integer_value]);
				return([-1, "A quality value of " + integer_value +
					" cannot be specified --- the valid range is from " +
					D2JSP_ITEM_QUALITY_LOW_QUALITY + " (" +
					D2JSP_ITEM_QualityToName(D2JSP_ITEM_QUALITY_LOW_QUALITY) + ") " +
					"to " + D2JSP_ITEM_QUALITY_MAXIMUM + " (" +
					D2JSP_ITEM_QualityToName(D2JSP_ITEM_QUALITY_MAXIMUM) + "), " +
					"inclusive."]);
			}
			else if ((this_value = D2JSP_ITEM_NameToQuality(qual_value)) != -1) {
				if (this_value != D2JSP_ITEM_QUALITY_NONE)
					return([0, this_value]);
				return([-1, "A quality value of none (0) cannot be specified."]);
			}
			return([-1, "Invalid quality value name ('" + qual_value + "')."]);
			break;
		case ISF_QUAL_NAME_TYPE_ITEMCLASS		:
			if (is_digit) {
				if ((integer_value >= D2JSP_ITEM_CLASS_MINIMUM) &&
					(integer_value <= D2JSP_ITEM_CLASS_MAXIMUM))
					return([0, integer_value]);
				return([-1, "An itemclass value of " + integer_value +
					" cannot be specified --- the valid range is from " +
					D2JSP_ITEM_CLASS_MINIMUM + " (" +
					D2JSP_ITEM_ItemClassToName(D2JSP_ITEM_CLASS_MINIMUM) + ") " +
					"to " + D2JSP_ITEM_CLASS_MAXIMUM + " (" +
					D2JSP_ITEM_ItemClassToName(D2JSP_ITEM_CLASS_MAXIMUM) + "), " +
					"inclusive."]);
			}
			else if ((this_value = D2JSP_ITEM_NameToItemClass(qual_value)) != -1)
				return([0, this_value]);
			return([-1, "Invalid itemclass value name ('" + qual_value + "')."]);
			break;
		case ISF_QUAL_NAME_TYPE_ITEMFLAG			:
			if (D2JSP_UTIL_FORMAT_IsBoolean(qual_value))
				return([0, qual_value]);
			return([-1, "Invalid item flag value --- expected a boolean."]);
			break;
		case ISF_QUAL_NAME_TYPE_PREFIX			:
		case ISF_QUAL_NAME_TYPE_SUFFIX			:
		case ISF_QUAL_NAME_TYPE_ITEMCODE			:
		case ISF_QUAL_NAME_TYPE_BASENAME			:
		case ISF_QUAL_NAME_TYPE_FULLNAME			:
			return([0, qual_value]);
			break;
		case ISF_QUAL_NAME_TYPE_SKILL_ALL		:
		case ISF_QUAL_NAME_TYPE_SKILL_CLASS		:
		case ISF_QUAL_NAME_TYPE_SKILL_TREE		:
		case ISF_QUAL_NAME_TYPE_SKILL_SINGLE	:
		case ISF_QUAL_NAME_TYPE_SKILL_ELEMENT	:
			if (is_integer)
				return([0, integer_value]);
			return([-1, "Invalid skill value specified ('" + qual_value + "') -- " +
				"an integer value was expected."]);
			break;
		case ISF_QUAL_NAME_TYPE_STAT_EXTENDED	:
			if (is_integer)
				return([0, integer_value]);
			return([-1, "Invalid stat value specified ('" + qual_value + "') -- " +
				"an integer value was expected."]);
			break;
		default											:
			return([-1, "INTERNAL PARSER ERROR: Invalid qualifier type ('" +
				qual_type + "')."]);
			break;
	}
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
// ////////////////////////////////////////////////////////////////////////////
// Mapping for a variety of extended stats...
// ////////////////////////////////////////////////////////////////////////////
var ISF_StatExtendedList = [
	["Enhanced Defense Percentage",			D2JSP_STAT_ITEM_ARMOR_PERCENT, 0],		// 16
	["Defense",										D2JSP_STAT_ARMORCLASS],						// 31
	["Plus Defense",								D2JSP_STAT_ARMORCLASS, 0],					// 31
	["Plus Defense Missile",					D2JSP_STAT_ARMORCLASS],						// 32
	["Plus Defense Hand-to-Hand",				D2JSP_STAT_ARMORCLASS],						// 33
	["Actual Minimum Damage",					D2JSP_STAT_MINDAMAGE],						// 21
	["Actual Minimum Damage One-Handed",	D2JSP_STAT_MINDAMAGE],						// 21
	["Actual Maximum Damage",					D2JSP_STAT_MAXDAMAGE],						// 22
	["Actual Maximum Damage One-Handed",	D2JSP_STAT_MAXDAMAGE],						// 22
	["Actual Minimum Damage Two-Handed",	D2JSP_STAT_SECONDARY_MINDAMAGE],			// 23
	["Actual Maximum Damage Two-Handed",	D2JSP_STAT_SECONDARY_MAXDAMAGE],			// 24
	["Plus Minimum Damage",						D2JSP_STAT_MINDAMAGE, 0],					// 21
	["Plus Minimum Damage One-Handed",		D2JSP_STAT_MINDAMAGE, 0],					// 21
	["Plus Minimum Damage Two-Handed",		D2JSP_STAT_SECONDARY_MINDAMAGE, 0],		// 23
	["Plus Maximum Damage",						D2JSP_STAT_MAXDAMAGE, 0],					// 22
	["Plus Maximum Damage One-Handed",		D2JSP_STAT_MAXDAMAGE, 0],					// 22
	["Plus Maximum Damage Two-Handed",		D2JSP_STAT_SECONDARY_MAXDAMAGE, 0],		// 24
	["Enhanced Damage Percentage",			D2JSP_STAT_ITEM_MINDAMAGE_PERCENT, 0],	// 18
	["Enhanced Damage Minimum Percentage",	D2JSP_STAT_ITEM_MINDAMAGE_PERCENT, 0],	// 18
	["Enhanced Damage Maximum Percentage",	D2JSP_STAT_ITEM_MAXDAMAGE_PERCENT, 0],	// 17
];
var ISF_StatExtendedMap = new Array();
for (var count_1 = 0; count_1 < ISF_StatExtendedList.length; count_1++) {
	this_name = ISF_StatExtendedList[count_1][0].toLowerCase();
	ISF_StatExtendedMap[this_name] = count_1;
}
delete this_name;
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
// ////////////////////////////////////////////////////////////////////////////
// Mapping for a variety of skill symbolic names...
// ////////////////////////////////////////////////////////////////////////////
var ISF_SkillNameList = new Array();
var ISF_SkillMap      = new Array();
	// Skill All
ISF_SkillMap["skill all"] = [ISF_QUAL_NAME_TYPE_SKILL_ALL, 127, null];
ISF_SkillNameList.push("Skill All");
	// Skill Class
ISF_SkillMap["skill class any"] = [ISF_QUAL_NAME_TYPE_SKILL_CLASS, 127, -1];
for (var count_1 = 0; count_1 < D2JSP_CLASS_ID_COUNT; count_1++) {
	ISF_SkillMap["skill " + D2JSP_CLASS_ID_NameList[count_1].toLowerCase()]       =
		[ISF_QUAL_NAME_TYPE_SKILL_CLASS, D2JSP_STAT_ClassToStatSkills[count_1], count_1];
	ISF_SkillMap["skill class " + D2JSP_CLASS_ID_NameList[count_1].toLowerCase()] =
		[ISF_QUAL_NAME_TYPE_SKILL_CLASS, D2JSP_STAT_ClassToStatSkills[count_1], count_1];
	ISF_SkillNameList.push("Skill Class " + D2JSP_CLASS_ID_NameList[count_1]);
}
	// Skill Tree
ISF_SkillMap["skill tree any"] =
	[ISF_QUAL_NAME_TYPE_SKILL_TREE, D2JSP_STAT_ITEM_ADDSKILL_TAB1, -1];
ISF_SkillNameList.push("Skill Tree Any");
for (var this_prop in D2JSP_SKILL_TreeNameList) {
	ISF_SkillMap["skill " + this_prop]      =
		[ISF_QUAL_NAME_TYPE_SKILL_TREE, D2JSP_STAT_ITEM_ADDSKILL_TAB1, D2JSP_SKILL_TreeNameList[this_prop]];
	ISF_SkillMap["skill tree " + this_prop] =
		[ISF_QUAL_NAME_TYPE_SKILL_TREE, D2JSP_STAT_ITEM_ADDSKILL_TAB1, D2JSP_SKILL_TreeNameList[this_prop]];
}
for (var count_1 = 0; count_1 < D2JSP_SKILL_TreeList.length; count_1++)
	ISF_SkillNameList.push("Skill Tree " + D2JSP_SKILL_TreeList[count_1].name);
	// Skill Single
for (var this_prop in D2JSP_SKILL_NameList) {
	ISF_SkillMap["skill " + this_prop.toLowerCase()]        =
		[ISF_QUAL_NAME_TYPE_SKILL_SINGLE, D2JSP_STAT_ITEM_SINGLESKILL1,
			D2JSP_SKILL_NameList[this_prop]];
	ISF_SkillMap["skill single " + this_prop.toLowerCase()] =
		[ISF_QUAL_NAME_TYPE_SKILL_SINGLE, D2JSP_STAT_ITEM_SINGLESKILL1,
			D2JSP_SKILL_NameList[this_prop]];
	ISF_SkillNameList.push("Skill Single " + D2JSP_UTIL_FORMAT_InitCaps(this_prop));
}
	// Skill Elemental
for (var count_1 = 0; count_1 < D2JSP_UTIL_DAMAGE_BaseElementList.length;
	count_1++) {
	ISF_SkillMap["skill elemental " + D2JSP_UTIL_DAMAGE_BaseElementList[count_1].toLowerCase()] =
		[ISF_QUAL_NAME_TYPE_SKILL_ELEMENT, D2JSP_STAT_ITEM_FIRESKILL, count_1];
	ISF_SkillMap["skill element " + D2JSP_UTIL_DAMAGE_BaseElementList[count_1].toLowerCase()]   =
		[ISF_QUAL_NAME_TYPE_SKILL_ELEMENT, D2JSP_STAT_ITEM_FIRESKILL, count_1];
	ISF_SkillNameList.push("Skill Elemental " + D2JSP_UTIL_DAMAGE_BaseElementList[count_1]);
}
/*
function main() {
	var file_handle = fileOpen("output/____________SKILL_MAP.txt", 1);
	for (var this_prop in ISF_SkillMap)
		file_handle.writeLine(this_prop + " = [" + ISF_SkillMap[this_prop] + "]");
}
*/
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
function ISF_PARSE_ParseQSpecNameStatExtended(qual_name)
{
	return(ISF_StatExtendedMap[qual_name.toLowerCase()]);
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
function ISF_PARSE_ParseQSpecNameSkill(qual_name)
{
	return(ISF_SkillMap[qual_name.toLowerCase()]);
}
// ////////////////////////////////////////////////////////////////////////////

// Ensures that an ISF QSpec value contains only valid characters.
// ////////////////////////////////////////////////////////////////////////////
function ISF_PARSE_IsValidQSpecValueString(qual_value)
{
	return((in_string.match(/^[A-Za-z0-9_\s]+$/)) ? true : false);
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
// ////////////////////////////////////////////////////////////////////////////
// This is the item object from 'getUnit(4)'/'getNext()' which will be used
// within the JavaScript 'eval()' statement.
// ////////////////////////////////////////////////////////////////////////////
var ISF_INTERNAL_ITEM_VAR	= "__PISF_item_obj__";
// ////////////////////////////////////////////////////////////////////////////

// Validates an ISF ISpec type number.
// ////////////////////////////////////////////////////////////////////////////
function ISF_ItemTypeIsValid(item_type)
{
	return(((typeof(item_type) == "number") &&
		(item_type >= ISF_ITEM_NAME_TYPE_MINIMUM) &&
		(item_type <= ISF_ITEM_NAME_TYPE_MAXIMUM)) ? true : false);
}
// ////////////////////////////////////////////////////////////////////////////

// Converts an ISF ISpec type number to its equivalent name.
// ////////////////////////////////////////////////////////////////////////////
function ISF_ItemTypeToName(item_type)
{
	return((ISF_ItemTypeIsValid(item_type)) ?
		ISF_ITEM_NAME_TYPE_NameList[item_type] : null);
}
// ////////////////////////////////////////////////////////////////////////////

// Converts an ISF ISpec type name to its equivalent number.
// ////////////////////////////////////////////////////////////////////////////
function ISF_ItemTypeNameToType(item_type_name)
{
	var item_type =
		ISF_ITEM_NAME_TYPE_NameToTypeList[item_type_name.toLowerCase()];

	return((typeof(item_type) == "number") ? item_type : -1);
}
// ////////////////////////////////////////////////////////////////////////////

// Validates an ISG QSpec type number.
// ////////////////////////////////////////////////////////////////////////////
function ISF_QualTypeIsValid(qual_type)
{
	return(((typeof(qual_type) == "number") &&
		(qual_type != ISF_QUAL_NAME_TYPE_NONE) &&
		(qual_type >= ISF_QUAL_NAME_TYPE_MINIMUM) &&
		(qual_type <= ISF_QUAL_NAME_TYPE_MAXIMUM)) ? true : false);
}
// ////////////////////////////////////////////////////////////////////////////

// Determines whether the specified ISF QSpec type is knowable for items which
// are not identified.
//
// NOTE: The function as written is incorrect, because (according to EagleHorn),
//			whether an item is ethereal is not reliably known before the item has
//			been identified.
// ////////////////////////////////////////////////////////////////////////////
function ISF_QualTypeIsKnownUnided(qual_type)
{
	return(((qual_type == ISF_QUAL_NAME_TYPE_QUALITY) ||
		(qual_type == ISF_QUAL_NAME_TYPE_ITEMCLASS) ||
		(qual_type == ISF_QUAL_NAME_TYPE_ITEMFLAG) ||
		(qual_type == ISF_QUAL_NAME_TYPE_ITEMCODE) ||
		(qual_type == ISF_QUAL_NAME_TYPE_BASENAME)) ? true : false);
}
// ////////////////////////////////////////////////////////////////////////////

// Determines the type of the ISF QSpec value based upon the ISF QSpec type.
// ////////////////////////////////////////////////////////////////////////////
function ISF_QualTypeToValueType(qual_type)
{
	return((!ISF_QualTypeIsValid(qual_type)) ?
		ISF_QUAL_VALUE_TYPE_NONE :
		((qual_type == ISF_QUAL_NAME_TYPE_PREFIX)  ||
		(qual_type == ISF_QUAL_NAME_TYPE_SUFFIX)   ||
		(qual_type == ISF_QUAL_NAME_TYPE_ITEMCODE) ||
		(qual_type == ISF_QUAL_NAME_TYPE_BASENAME) ||
		(qual_type == ISF_QUAL_NAME_TYPE_FULLNAME)) ?
		ISF_QUAL_VALUE_TYPE_STRING :
		(qual_type == ISF_QUAL_NAME_TYPE_ITEMFLAG) ?
		ISF_QUAL_VALUE_TYPE_BOOLEAN : ISF_QUAL_VALUE_TYPE_NUMBER);
}
// ////////////////////////////////////////////////////////////////////////////

// Converts an ISF QSpec type number to its equivalent name.
// ////////////////////////////////////////////////////////////////////////////
function ISF_QualTypeToName(qual_type)
{
	return((ISF_QualTypeIsValid(qual_type)) ?
		ISF_QUAL_NAME_TYPE_NameList[qual_type] : null);
}
// ////////////////////////////////////////////////////////////////////////////

// Converts an ISF QSpec type name to its equivalent number.
// ////////////////////////////////////////////////////////////////////////////
function ISF_QualTypeNameToType(qual_type_name)
{
	var qual_type =
		ISF_QUAL_NAME_TYPE_NameToTypeList[qual_type_name.toLowerCase()];

	return(((typeof(qual_type) == "number") &&
		(qual_type != ISF_QUAL_NAME_TYPE_NONE)) ? qual_type : -1);
}
// ////////////////////////////////////////////////////////////////////////////

// Ensures that the type of an expression value is correct for the specified
// ISF QSpec type.
// ////////////////////////////////////////////////////////////////////////////
function ISF_QualValueIsValid(qual_type, qual_value)
{
	var qual_value_type = ISF_QualTypeToValueType(qual_type);

	return((((qual_value_type == ISF_QUAL_VALUE_TYPE_STRING) &&
		(typeof(qual_value) == "string")) ||
		((qual_value_type == ISF_QUAL_VALUE_TYPE_BOOLEAN) &&
		(typeof(qual_value) == "number") &&
		((!qual_value) || (qual_value == 1))) ||
		(typeof(qual_value) == "number")) ? true : false);
}
// ////////////////////////////////////////////////////////////////////////////

// Converts an ISF QSpec to a string ready for parsing.
// ////////////////////////////////////////////////////////////////////////////
function ISF_QualToString(qual_type, qual_name, qual_op, qual_value, qual_other)
{
	var rvalue = null;
	var lvalue = null;

  switch (qual_type) {
		case ISF_QUAL_NAME_TYPE_STAT			:
			lvalue = D2JSP_STAT_StatToName(qual_name);
			break;
		case ISF_QUAL_NAME_TYPE_QUALITY		:
			lvalue = ISF_QualTypeToName(qual_type);
			rvalue = D2JSP_ITEM_QualityToName(qual_value);
			break;
		case ISF_QUAL_NAME_TYPE_ITEMCLASS	:
			lvalue = ISF_QualTypeToName(qual_type);
			rvalue = D2JSP_ITEM_ItemClassToName(qual_value);
			break;
		case ISF_QUAL_NAME_TYPE_ITEMFLAG	:
//			lvalue = ISF_QualTypeToName(qual_type);
			rvalue = (qual_value) ? "true" : "false";
			break;
		case ISF_QUAL_NAME_TYPE_PREFIX		:
		case ISF_QUAL_NAME_TYPE_SUFFIX		:
		case ISF_QUAL_NAME_TYPE_ITEMCODE	:
		case ISF_QUAL_NAME_TYPE_BASENAME	:
		case ISF_QUAL_NAME_TYPE_FULLNAME	:
			lvalue = ISF_QualTypeToName(qual_type);
			break;
		case ISF_QUAL_NAME_TYPE_SKILL_ALL		:
			lvalue = "Skill All";
			break;
		case ISF_QUAL_NAME_TYPE_SKILL_CLASS		:
			lvalue = "Skill Class " +
				((qual_other == -1) ? "Any" : D2JSP_CLASS_ID_NameList[qual_other]);
			break;
		case ISF_QUAL_NAME_TYPE_SKILL_TREE		:
			lvalue = "Skill Tree " +
				((qual_other == -1) ? "Any" : qual_other.name);
			break;
		case ISF_QUAL_NAME_TYPE_SKILL_SINGLE	:
			lvalue = "Skill Single " + D2JSP_SKILL_SkillList[qual_other];
			break;
		case ISF_QUAL_NAME_TYPE_SKILL_ELEMENT	:
			lvalue = "Skill Elemental " + D2JSP_UTIL_DAMAGE_BaseElementList[qual_other];
			break;
		case ISF_QUAL_NAME_TYPE_STAT_EXTENDED	:
			lvalue = ISF_StatExtendedList[qual_other][0];
			break;
		default											:
			break;								// May have noticed no error-checking...
	}

	return(((lvalue != null) ? lvalue : qual_name) + " " + qual_op + " " +
		((rvalue != null) ? rvalue : qual_value));
}

// CODE NOTE: Testing function --- to be removed.
function ISF_QualToStringX(qual_type, qual_name, qual_op, qual_value, qual_other)
{
	var rvalue = null;
	var lvalue = null;

  switch (qual_type) {
		case ISF_QUAL_NAME_TYPE_STAT			:
			lvalue = D2JSP_STAT_StatToName(qual_name);
			break;
		case ISF_QUAL_NAME_TYPE_QUALITY		:
			lvalue = ISF_QualTypeToName(qual_type);
			rvalue = D2JSP_ITEM_QualityToName(qual_value);
			break;
		case ISF_QUAL_NAME_TYPE_ITEMCLASS	:
			lvalue = ISF_QualTypeToName(qual_type);
			rvalue = D2JSP_ITEM_ItemClassToName(qual_value);
			break;
		case ISF_QUAL_NAME_TYPE_ITEMFLAG	:
			lvalue = ISF_QualTypeToName(qual_type);
			rvalue = (qual_value) ? "true" : "false";
			break;
		case ISF_QUAL_NAME_TYPE_PREFIX		:
		case ISF_QUAL_NAME_TYPE_SUFFIX		:
		case ISF_QUAL_NAME_TYPE_ITEMCODE	:
		case ISF_QUAL_NAME_TYPE_BASENAME	:
		case ISF_QUAL_NAME_TYPE_FULLNAME	:
			lvalue = ISF_QualTypeToName(qual_type)+".toLowerCase()";
			rvalue = qual_value.toLowerCase();
			break;
		case ISF_QUAL_NAME_TYPE_SKILL_ALL		:
			lvalue = "Skill All";
			break;
		case ISF_QUAL_NAME_TYPE_SKILL_CLASS		:
			lvalue = "Skill Class " +
				((qual_other == -1) ? "Any" : D2JSP_CLASS_ID_NameList[qual_other]);
			break;
		case ISF_QUAL_NAME_TYPE_SKILL_TREE		:
			lvalue = "Skill Tree " +
				((qual_other == -1) ? "Any" : qual_other.name);
			break;
		case ISF_QUAL_NAME_TYPE_SKILL_SINGLE	:
			lvalue = "Skill Single " + D2JSP_SKILL_SkillList[qual_other];
			break;
		case ISF_QUAL_NAME_TYPE_SKILL_ELEMENT	:
			lvalue = "Skill Elemental " + D2JSP_UTIL_DAMAGE_BaseElementList[qual_other];
			break;
		case ISF_QUAL_NAME_TYPE_STAT_EXTENDED	:
			lvalue = ISF_StatExtendedList[qual_other][0];
			break;
		default											:
			break;								// May have noticed no error-checking...
	}

	return(((lvalue != null) ? lvalue : qual_name) + " " + qual_op + " " +
		((rvalue != null) ? rvalue : qual_value) + "X");
}
// ////////////////////////////////////////////////////////////////////////////

// Converts an ISF QSpec to a string ready for use by 'eval()'.
// ////////////////////////////////////////////////////////////////////////////
function ISF_QualToEvalString(qual_type, qual_name, qual_op, qual_value, qual_other)
{
	var lvalue;

	switch (qual_type) {
		case ISF_QUAL_NAME_TYPE_STAT			:
//			lvalue = ISF_INTERNAL_ITEM_VAR + ".getStat(" + qual_name + ")";
			// Needed for 1.10 to use <item>.getStat[Ex]()
			lvalue = "D2JSP_STAT_Get(" + ISF_INTERNAL_ITEM_VAR + ", " + qual_name + ")";
			break;
		case ISF_QUAL_NAME_TYPE_QUALITY		:
			lvalue = ISF_INTERNAL_ITEM_VAR + ".quality";
			break;
		case ISF_QUAL_NAME_TYPE_ITEMCLASS	:
			lvalue = "D2JSP_ITEM_GetItemClass(" + ISF_INTERNAL_ITEM_VAR + ")";
			break;
		case ISF_QUAL_NAME_TYPE_PREFIX		:
			// Work-around for unidentifed rare affix bug in core.
			lvalue = "D2JSP_ITEM_GetItemPrefix(" + ISF_INTERNAL_ITEM_VAR + ")";
			break;
		case ISF_QUAL_NAME_TYPE_SUFFIX		:
			// Work-around for unidentifed rare affix bug in core.
			lvalue = "D2JSP_ITEM_GetItemSuffix(" + ISF_INTERNAL_ITEM_VAR + ")";
			break;
		case ISF_QUAL_NAME_TYPE_ITEMFLAG	:
			lvalue = ISF_INTERNAL_ITEM_VAR + ".getFlag(" +
				"0x" + D2JSP_ITEMFLAG_NameToItemFlag(qual_name).toString(16) + ")";
			break;
		case ISF_QUAL_NAME_TYPE_ITEMCODE	:
			lvalue = ISF_INTERNAL_ITEM_VAR + ".code";
			break;
		case ISF_QUAL_NAME_TYPE_BASENAME	:
			lvalue = ISF_INTERNAL_ITEM_VAR + ".name";
			break;
		case ISF_QUAL_NAME_TYPE_FULLNAME	:
			lvalue = "D2JSP_ITEM_GetItemFName(" + ISF_INTERNAL_ITEM_VAR + ")";
			break;
		case ISF_QUAL_NAME_TYPE_SKILL_ALL		:
			lvalue = ISF_INTERNAL_ITEM_VAR + ".getStat(" +
				D2JSP_STAT_ITEM_ALLSKILLS + ")";
			break;
		case ISF_QUAL_NAME_TYPE_SKILL_CLASS		:
			if (parseFloat(me.version) < 0.3530) {
				if (qual_other == -1) {
					lvalue = "";
					for (var count_1 = 0; count_1 < D2JSP_CLASS_ID_COUNT; count_1++)
						lvalue += ((lvalue != "") ? " || " : "(") + "(" +
							ISF_INTERNAL_ITEM_VAR + ".getStat(" +
							D2JSP_STAT_ClassToStatSkills[count_1] + ") " +
							ISF_QUAL_OP_MapToJSList[qual_op] + " " + qual_value +
							")";
					return(lvalue + ")");
				}
				lvalue = ISF_INTERNAL_ITEM_VAR + ".getStat(" + qual_name + ")";
			}
			else if (qual_other == -1) {
				lvalue = "";
				for (var count_1 = 0; count_1 < D2JSP_CLASS_ID_COUNT; count_1++)
					lvalue += ((lvalue != "") ? " || " : "(") + "(" +
						ISF_INTERNAL_ITEM_VAR + ".getStat(" +
						D2JSP_STAT_ITEM_ADDAMASKILLPOINTS + ", " + count_1 + ") " +
						ISF_QUAL_OP_MapToJSList[qual_op] + " " + qual_value + ")";
				return(lvalue + ")");
			}
			else
				lvalue = ISF_INTERNAL_ITEM_VAR + ".getStat(" +
					D2JSP_STAT_ITEM_ADDAMASKILLPOINTS + ", " + qual_other + ")";
			break;
		case ISF_QUAL_NAME_TYPE_SKILL_TREE		:
			if (parseFloat(me.version) < 0.3530) {
				lvalue = ISF_INTERNAL_ITEM_VAR + ".getStat(" +
					D2JSP_STAT_ITEM_ADDSKILL_TAB1 + ")";
				rvalue = qual_other.value_109 + (qual_value * 32);
			}
			else if (qual_other == -1) {
				lvalue = "";
				for (var this_prop in D2JSP_SKILL_TreeList)
					lvalue += ((lvalue != "") ? " || " : "(") + "(" +
						ISF_INTERNAL_ITEM_VAR + ".getStat(" +
						D2JSP_STAT_ITEM_ADDSKILL_TAB1 + ", " +
						D2JSP_SKILL_TreeList[this_prop].value_110 + ") " +
						ISF_QUAL_OP_MapToJSList[qual_op] + " " + qual_value + ")";
				return(lvalue + ")");
			}
			else
				lvalue = ISF_INTERNAL_ITEM_VAR + ".getStat(" +
					D2JSP_STAT_ITEM_ADDSKILL_TAB1 + ", " + qual_other.value_110 + ")";
			break;
		case ISF_QUAL_NAME_TYPE_SKILL_SINGLE	:
			if (parseFloat(me.version) < 0.3530) {
				lvalue = ISF_INTERNAL_ITEM_VAR + ".getStat(" +
					D2JSP_STAT_ITEM_SINGLESKILL1 + ")";
				rvalue = qual_other + (qual_value * 512);
			}
			else
				lvalue = ISF_INTERNAL_ITEM_VAR + ".getStat(" +
					D2JSP_STAT_ITEM_SINGLESKILL1 + ", " + qual_other + ")";
			break;
		case ISF_QUAL_NAME_TYPE_SKILL_ELEMENT	:
			if (parseFloat(me.version) < 0.3530)
				lvalue = ISF_INTERNAL_ITEM_VAR + ".getStat(" +
					D2JSP_STAT_ITEM_FIRESKILL + ")";
			else
				lvalue = ISF_INTERNAL_ITEM_VAR + ".getStat(" +
					D2JSP_STAT_ITEM_FIRESKILL + ", " + qual_other + ")";
			break;
		case ISF_QUAL_NAME_TYPE_STAT_EXTENDED	:
			if (parseFloat(me.version) < 0.3530)
				lvalue = ISF_INTERNAL_ITEM_VAR + ".getStat(" +
					ISF_StatExtendedList[qual_other][1] + ")";
			else
				lvalue = ISF_INTERNAL_ITEM_VAR + ".getStat(" +
					ISF_StatExtendedList[qual_other][1] +
					((ISF_StatExtendedList[qual_other].length == 2) ? "" :
					(", " + ISF_StatExtendedList[qual_other][2])) + ")";
			break;
		default											:
			return("");							// Really an error. Should throw()?
	}

	if (ISF_QualTypeToValueType(qual_type) ==
		ISF_QUAL_VALUE_TYPE_STRING) {
		lvalue     += ".toLowerCase()";
		qual_value  = "\"" + qual_value.toLowerCase() + "\"";
	}

//print("(" + lvalue + " " + ISF_QUAL_OP_MapToJSList[qual_op] + " " +
//	qual_value + ")");

return("(" + lvalue + " " + ISF_QUAL_OP_MapToJSList[qual_op] + " " + qual_value + ")");

	return("(" + lvalue + " " + ISF_QUAL_OP_MapToJSList[qual_op] + " " +
		((ISF_QualTypeToValueType(qual_type) ==
		ISF_QUAL_VALUE_TYPE_STRING) ? ("\"" + qual_value + "\"") :
		qual_value) + ")");
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
// ////////////////////////////////////////////////////////////////////////////
// Object 'ISF_QSpec'...
// ////////////////////////////////////////////////////////////////////////////
function ISF_QSpec(qual_type, qual_name, qual_op, qual_value, qual_other)
{
	var parse_results;

	if (arguments.length >= 4) {
		this.qual_type  = qual_type;
		this.qual_name  = qual_name;
		this.qual_op    = qual_op;
		this.qual_value = qual_value;
		this.qual_other = (arguments.length == 5) ? qual_other : null;
	}

	this.toString     = ISF_QSpecToString;
	this.toText       = ISF_QSpecToText;
	this.toEvalString = ISF_QSpecToEvalString;
}

function ISF_QSpecToString()
{
if (0)
	return(ISF_QualToStringX(this.qual_type, this.qual_name,
		this.qual_op, this.qual_value, this.qual_other));
else
	return(ISF_QualToEvalString(this.qual_type, this.qual_name,
		this.qual_op, this.qual_value, this.qual_other));
}

function ISF_QSpecToText()
{
	return(ISF_QualToString(this.qual_type, this.qual_name,
		this.qual_op, this.qual_value, this.qual_other));
}

function ISF_QSpecToEvalString()
{
	return(ISF_QualToEvalString(this.qual_type, this.qual_name,
		this.qual_op, this.qual_value, this.qual_other));
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
// ////////////////////////////////////////////////////////////////////////////
// Object 'ISF_ISpec'...
// ////////////////////////////////////////////////////////////////////////////
function ISF_ISpec(item_priority, item_type, item_name)
{
	if (arguments.length == 3) {
		this.item_priority = (typeof(item_priority) == "number") ? item_priority :
			ISF_SPEC_ITEM_PRIORITY_MAX_ITEM;
		this.item_type     = item_type;
		this.item_name     = item_name;
	}

	this.toString = ISF_ISpecToString;
}

function ISF_ISpecToString()
{
/*
	return(((this.item_priority == ISF_SPEC_ITEM_PRIORITY_MAX_ITEM) ? "" :
		(this.item_priority + "@")) +
		((this.item_type != ISF_ITEM_NAME_TYPE_ITEMCODE) ?
		(ISF_ItemTypeToName(this.item_type) + " ") : "") + this.item_name);
*/
	return((this.item_priority + "@") +
		(ISF_ItemTypeToName(this.item_type) + " ") + this.item_name);
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
// ////////////////////////////////////////////////////////////////////////////
// Object 'ISF_Specifier'...
// ////////////////////////////////////////////////////////////////////////////
function ISF_Specifier(src_name, src_line, ispec_list, qspec_list)
{
	var count_1;

	if (arguments.length == 4) {
		this.src_name     = src_name;			// This is an array index.
		this.src_line     = src_line;
		this.ispec_list   = D2JSP_UTIL_GEN_CloneObject(ispec_list);
		this.qspec_list   = D2JSP_UTIL_GEN_CloneObject(qspec_list);
		this.known_unided = true;
		for (count_1 = 0; count_1 < this.qspec_list.length; count_1++) {
			if (!ISF_QualTypeIsKnownUnided(this.qspec_list[count_1].qual_type)) {
				this.known_unided = false;
				break;
			}
		}
	}

	this.toString            = ISF_SpecifierToString;
	this.toText              = ISF_SpecifierToText;
	this.sourceString        = ISF_SourceString;
	this.sourceStringFromISF = ISF_SourceStringFromISF;
}

function ISF_SpecifierToString(src_name_list)
{
	return("File: " +
		((src_name_list != null) ? src_name_list[this.src_name] : "*UNKNOWN*") +
		"|Line: " + this.src_line + "|" +
		this.ispec_list + ":" + this.qspec_list.join(":"));
}

function ISF_SpecifierToText()
{
	var tmp_string = this.ispec_list;

	for (var count_1 = 0; count_1 < this.qspec_list.length; count_1++)
		tmp_string += " : " + this.qspec_list[count_1].toText();

	return(tmp_string);
}

function ISF_SourceString(src_name_list)
{
	return("Line Number: " + D2JSP_UTIL_FORMAT_RJust(this.src_line, 10) +
		" ---> File Name: " + src_name_list[this.src_name]);
}

function ISF_SourceStringFromISF(isf_cfg)
{
	return(this.sourceString(isf_cfg[ISF_COMPILED_DATA_SRC_LIST]));
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
// ////////////////////////////////////////////////////////////////////////////
// Object 'ISF_CfgTriple'...
// ////////////////////////////////////////////////////////////////////////////
function ISF_CfgTriple(isf_cfg_stash, isf_cfg_sell, isf_cfg_merged)
{
	this.isf_cfg_stash           = isf_cfg_stash;
	this.isf_cfg_sell            = isf_cfg_sell;
	this.isf_cfg_merged          = isf_cfg_merged;

	this.toString                = ISF_CfgTriple_toString;
	this.cursorCheckStart        = ISF_CfgTriple_cursorCheckStart;
	this.doPickup                = ISF_CfgTriple_doPickup;
	this.doStashing              = ISF_CfgTriple_doStashing;
	this.doSelling               = ISF_CfgTriple_doSelling;
	this.getStashActionList      = ISF_CfgTriple_getStashActionList;
	this.getSellActionList       = ISF_CfgTriple_getSellActionList;
	this.getStashActionListBasic = ISF_CfgTriple_getStashActionListBasic;
	this.getMatchActionList      = ISF_CfgTriple_getMatchActionList;

	// //////////////////////////////////////////////////////////////////////
	// //////////////////////////////////////////////////////////////////////
	// Now for the important stuff...
	// //////////////////////////////////////////////////////////////////////
	function ISF_CfgTriple_cursorCheckStart() {
		return(this.isf_cfg_stash.cursorCheckStart());
	}
	function ISF_CfgTriple_doPickup(pickup_flags, pickup_radius, belt_flags,
		min_gold_amount, destination, callback_func, callback_data) {
		return(this.isf_cfg_merged.doPickup(pickup_flags, pickup_radius,
			belt_flags, min_gold_amount, destination, callback_func,
			callback_data));
	}
	function ISF_CfgTriple_doStashing(exclude_list, stash_flags) {
		return(this.isf_cfg_stash.doStashing(exclude_list, stash_flags));
	}
	function ISF_CfgTriple_doSelling(exclude_list, stash_flags) {
/*
		D2JSP_UTIL_LOG_GetALog().logWarning(
			"ISF_CfgTriple.doSelling() not yet supported.");
		return(-1);
*/
		var return_code = 0;
		var sell_list   = this.getSellActionList(stash_flags, exclude_list);

		if (sell_list.length) {
			return_code = ISF_DoSellingInternal(this.isf_cfg_stash.isf_cmp,
				sell_list, stash_flags);
			if (this.getStashActionList(stash_flags, exclude_list).length)
				return_code = this.isf_cfg_stash.doStashing(exclude_list,
					stash_flags);
			else {
				var stash_obj;
				if ((stash_obj = getUnit(D2JSP_UTIL_GETUNIT_OBJECT, "Bank")) != null)
					D2JSP_UTIL_GEN_CancelObject(stash_obj);
			}
		}

		if (this.getStashActionList(stash_flags, exclude_list).length)
			return_code = this.isf_cfg_stash.doStashing(exclude_list, stash_flags);

		return(return_code);
	}
	function ISF_CfgTriple_getStashActionList(stash_flags, exclude_list) {
		return(this.isf_cfg_stash.getStashActionList(stash_flags, exclude_list));
	}
	function ISF_CfgTriple_getSellActionList(stash_flags, exclude_list) {
/*
		D2JSP_UTIL_LOG_GetALog().logWarning(
			"ISF_CfgTriple.getSellActionList() not yet supported.");
		return(new Array());
*/
		var sell_list_1 = this.isf_cfg_stash.getMatchActionList();
		var sell_list_2 = this.isf_cfg_sell.getMatchActionList();

		// ////////////////////////////////////////////////////////////////
		// ////////////////////////////////////////////////////////////////
		//	Remove any items in the sell ISF which are also in stash ISF...
		// ////////////////////////////////////////////////////////////////
		for (var count_1 = 0; count_1 < sell_list_2.length; ) {
			var found_flag = false;
			for (var count_2 = 0; count_2 < sell_list_1.length; count_2++) {
				if (ISF_SISpec_isEqual(sell_list_2[count_1], sell_list_1[count_2]) &&
					sell_list_1[count_2].isf_item_flag) {
					sell_list_2.splice(count_1, 1);
					found_flag = true;
					break;
				}
			}
			if (!found_flag)
				count_1++;
		}
		// ////////////////////////////////////////////////////////////////
		// ////////////////////////////////////////////////////////////////
		//	Include items for selling from the stash ISF only if they're
		//	unidentified and need to be evaluated for keeping by identifing
		// them...
		// ////////////////////////////////////////////////////////////////
		for (var count_1 = 0; count_1 < sell_list_1.length; ) {
			if (sell_list_1[count_1].id_flag)
				count_1++;
			else
				sell_list_1.splice(count_1, 1);
		}
		// ////////////////////////////////////////////////////////////////
		// ////////////////////////////////////////////////////////////////
		//	Any items in the sell ISF which are not identified need to be
		// before sale...
		// ////////////////////////////////////////////////////////////////
		for (var count_1 = 0; count_1 < sell_list_2.length; count_1++) {
			if (!sell_list_2[count_1].is_identified)
				sell_list_2[count_1].id_flag = true;
		}
		// ////////////////////////////////////////////////////////////////
		return(sell_list_1.concat(sell_list_2));
	}
	function ISF_CfgTriple_getStashActionListBasic(action_flag, stash_flags,
		exclude_list) {
/*
		D2JSP_UTIL_LOG_GetALog().logWarning(
			"ISF_CfgTriple.getStashActionListBasic() not yet supported.");
		return(new Array());
*/
		return(ISF_GetStashActionListBasic(this.isf_cfg_merged.isf_cmp,
			action_flag, stash_flags, exclude_list));
	}
	function ISF_CfgTriple_getMatchActionList(stash_flags, exclude_list) {
/*
		D2JSP_UTIL_LOG_GetALog().logWarning(
			"ISF_CfgTriple.getMatchActionList() not yet supported.");
		return(new Array());
*/
		return(ISF_GetMatchActionList(this.isf_cfg_merged.isf_cmp, stash_flags,
			exclude_list));
	}
	// //////////////////////////////////////////////////////////////////////

	function ISF_CfgTriple_toString() {
		return("ISF triple configuration: stash cfg=[" + this.isf_cfg_stash +
			"], sell cfg=[" + this.isf_cfg_sell + "], merged cfg =[" +
			this.isf_cfg_merged + "]");
	}
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
// ////////////////////////////////////////////////////////////////////////////
// Object 'ISF_Cfg'...
// ////////////////////////////////////////////////////////////////////////////
function ISF_Cfg(isf_cmp)
{
	// //////////////////////////////////////////////////////////////////////
	// //////////////////////////////////////////////////////////////////////
	// We can create an empty ISF object if we have to...
	// //////////////////////////////////////////////////////////////////////
	if ((arguments.length != 1) ||
		(!D2JSP_UTIL_GEN_TypeOfArrayIndexed(isf_cmp)) ||
		(isf_cmp.length != ISF_COMPILED_DATA_COUNT)) {
		this.isf_cmp                              =
			new Array(ISF_COMPILED_DATA_COUNT);
		this.isf_cmp[ISF_COMPILED_DATA_VERSION]   = ISF_VERSION_NUMBER;
		this.isf_cmp[ISF_COMPILED_DATA_SOURCE]    = ISF_INTERNAL_SOURCE_NAME;
		this.isf_cmp[ISF_COMPILED_DATA_DATE]      = new Date();
		this.isf_cmp[ISF_COMPILED_DATA_CHECKSUM]  = "CHECKSUM NOT IMPLEMENTED";
		this.isf_cmp[ISF_COMPILED_DATA_SRC_LIST]  = [ISF_INTERNAL_SOURCE_NAME];
		this.isf_cmp[ISF_COMPILED_DATA_SPEC_LIST] = new Array();
		this.isf_cmp[ISF_COMPILED_DATA_PRIORITY]  = new Array();
		this.isf_cmp[ISF_COMPILED_DATA_PICKUP]    = new Array();
		this.isf_cmp[ISF_COMPILED_DATA_ID]        = new Array();
		this.isf_cmp[ISF_COMPILED_DATA_EVAL]      = new Array();
	}
	else
//		this.isf_cmp = D2JSP_UTIL_GEN_CloneObject(isf_cmp);
		this.isf_cmp = isf_cmp;
	// //////////////////////////////////////////////////////////////////////

	// //////////////////////////////////////////////////////////////////////
	// //////////////////////////////////////////////////////////////////////
	// And the other members...
	// //////////////////////////////////////////////////////////////////////
	this.version                 = this.isf_cmp[ISF_COMPILED_DATA_VERSION];
	this.source                  = this.isf_cmp[ISF_COMPILED_DATA_SOURCE];
	this.cmp_date                = this.isf_cmp[ISF_COMPILED_DATA_DATE];
	this.checksum                = this.isf_cmp[ISF_COMPILED_DATA_CHECKSUM];
	this.src_list                = this.isf_cmp[ISF_COMPILED_DATA_SRC_LIST];
	this.spec_list               = this.isf_cmp[ISF_COMPILED_DATA_SPEC_LIST];
	this.priority_list           = this.isf_cmp[ISF_COMPILED_DATA_PRIORITY];
	this.eval_pickup_list        = this.isf_cmp[ISF_COMPILED_DATA_PICKUP];
	this.eval_id_list            = this.isf_cmp[ISF_COMPILED_DATA_ID];
	this.eval_keep_list          = this.isf_cmp[ISF_COMPILED_DATA_EVAL];
	this.getVersion              = ISF_Cfg_getVersion;
	this.getVersion              = ISF_Cfg_getVersion;
	this.getSource               = ISF_Cfg_getSource;
	this.getCompileDate          = ISF_Cfg_getCompileDate;
	this.getChecksum             = ISF_Cfg_getChecksum;
	this.getSourceList           = ISF_Cfg_getSourceList;
	this.getSpecCount            = ISF_Cfg_getSpecCount;
	this.getSpecList             = ISF_Cfg_getSpecList;
	this.getCodeList             = ISF_Cfg_getCodeList;
	this.getSpec                 = ISF_Cfg_getSpec;
	this.getSpecString           = ISF_Cfg_getSpecString;
	this.getSpecText             = ISF_Cfg_getSpecText;
	this.getCode                 = ISF_Cfg_getCode;
	this.getSpecDataList         = ISF_Cfg_getSpecDataList;
	this.getSpecStringDataList   = ISF_Cfg_getSpecStringDataList;
	this.toString                = ISF_Cfg_toString;
	this.cursorCheckStart        = ISF_Cfg_cursorCheckStart;
	this.doPickup                = ISF_Cfg_doPickup;
	this.doStashing              = ISF_Cfg_doStashing;
	this.doSelling               = ISF_Cfg_doSelling;
	this.getStashActionList      = ISF_Cfg_getStashActionList;
	this.getSellActionList       = ISF_Cfg_getSellActionList;
	this.getStashActionListBasic = ISF_Cfg_getStashActionListBasic;
	this.getMatchActionList      = ISF_Cfg_getMatchActionList;
	this.evalItemForPickup       = ISF_Cfg_evalItemForPickup;
	this.evalItemForKeep         = ISF_Cfg_evalItemForKeep;
	this.evalItemForId           = ISF_Cfg_evalItemForId;
	this.evalItem                = ISF_Cfg_evalItem;
	// //////////////////////////////////////////////////////////////////////

	// //////////////////////////////////////////////////////////////////////
	// //////////////////////////////////////////////////////////////////////
	// A variety of miscellaneous get accessors...
	// //////////////////////////////////////////////////////////////////////
	function ISF_Cfg_getVersion()     { return(ISF_Cfg_get(this, "version")); }
	function ISF_Cfg_getSource()      { return(ISF_Cfg_get(this, "source"));  }
	function ISF_Cfg_getCompileDate() { return(ISF_Cfg_get(this, "cmp_date"));}
	function ISF_Cfg_getChecksum()    { return(ISF_Cfg_get(this, "checksum"));}
	function ISF_Cfg_getSourceList()  { return(ISF_Cfg_get(this, "src_list"));}
	function ISF_Cfg_getSpecCount()   { return(this.spec_list.length);}
	function ISF_Cfg_getSpecList()    { return(ISF_Cfg_get(this, "spec_list"));}
	function ISF_Cfg_getCodeList()    { return(ISF_Cfg_get(this, "eval_id_list"));}
	function ISF_Cfg_getSpec(spec_id) {
		return(((spec_id >= 0) && (spec_id < this.spec_list.length)) ?
			[spec_id, D2JSP_UTIL_GEN_CloneObject(this.spec_list[spec_id].src_name),
			D2JSP_UTIL_GEN_CloneObject(this.spec_list[spec_id])] : null);
	}
	function ISF_Cfg_getSpecString(spec_id) {
		return(((spec_id >= 0) && (spec_id < this.spec_list.length)) ?
			D2JSP_UTIL_GEN_CloneObject(this.spec_list[spec_id].
			sourceStringFromISF(this.isf_cmp)) : null);
	}
	function ISF_Cfg_getSpecText(spec_id) {
		return(((spec_id >= 0) && (spec_id < this.spec_list.length)) ?
			this.spec_list[spec_id].toText() : null);
	}
	function ISF_Cfg_getCode(item_code) {
		return(D2JSP_UTIL_GEN_CloneObject(this.eval_id_list[item_code]));
	}
	function ISF_Cfg_getSpecDataList() {
		var out_list = new Array();
		for (var count_1 = 0; count_1 < this.spec_list.length; count_1++)
			out_list.push(this.getSpec(count_1));
		return(out_list);
	}
	function ISF_Cfg_getSpecStringDataList() {
		var out_list = new Array();
		for (var count_1 = 0; count_1 < this.spec_list.length; count_1++)
			out_list.push(this.getSpecString(count_1));
		return(out_list);
	}
	// Can't use 'this' because the object is incompletely formed at this stage.
	function ISF_Cfg_get(that, data_name) {
		return(D2JSP_UTIL_GEN_CloneObject(that[data_name]));
	}
	function ISF_Cfg_toString() {
		return("ISF configuration version " + this.version + " compiled on " +
			this.cmp_date + " from source data " + this.source);
	}
	// //////////////////////////////////////////////////////////////////////

	// //////////////////////////////////////////////////////////////////////
	// //////////////////////////////////////////////////////////////////////
	// Now for the important stuff...
	// //////////////////////////////////////////////////////////////////////
	function ISF_Cfg_cursorCheckStart() {
		return(ISF_CursorCheckStart(this.isf_cmp));
	}
	function ISF_Cfg_doPickup(pickup_flags, pickup_radius, belt_flags,
		min_gold_amount, destination, callback_func, callback_data) {
		return(ISF_DoPickup(this.isf_cmp, pickup_flags, pickup_radius, belt_flags,
			min_gold_amount, destination, callback_func, callback_data));
	}
	function ISF_Cfg_doStashing(exclude_list, stash_flags) {
		return(ISF_DoStashing(this.isf_cmp, exclude_list, stash_flags));
	}
	function ISF_Cfg_doSelling(exclude_list, stash_flags) {
		return(ISF_DoSelling(this.isf_cmp, exclude_list, stash_flags));
	}
	function ISF_Cfg_getStashActionList(stash_flags, exclude_list) {
		return(ISF_GetStashActionList(this.isf_cmp, stash_flags, exclude_list));
	}
	function ISF_Cfg_getSellActionList(stash_flags, exclude_list) {
		return(ISF_GetSellActionList(this.isf_cmp, stash_flags, exclude_list));
	}
	function ISF_Cfg_getStashActionListBasic(action_flag, stash_flags,
		exclude_list) {
		return(ISF_GetStashActionListBasic(this.isf_cmp, action_flag, stash_flags,
			exclude_list));
	}
	function ISF_Cfg_getMatchActionList(stash_flags, exclude_list) {
		return(ISF_GetMatchActionList(this.isf_cmp, stash_flags, exclude_list));
	}
	// //////////////////////////////////////////////////////////////////////

	// //////////////////////////////////////////////////////////////////////
	// //////////////////////////////////////////////////////////////////////
	// These are interesting for application programmers who need a bit more
	// control of script function...
	// //////////////////////////////////////////////////////////////////////
	function ISF_Cfg_evalItemForPickup(eval_item, eval_flags) {
		return(ISF_EvalItemForPickup(this.isf_cmp, eval_item, eval_flags));
	}
	function ISF_Cfg_evalItemForKeep(eval_item, eval_flags) {
		return(ISF_EvalItemForKeep(this.isf_cmp, eval_item, eval_flags));
	}
	function ISF_Cfg_evalItemForId(eval_item, eval_flags) {
		return(ISF_EvalItemForId(this.isf_cmp, eval_item, eval_flags));
	}
	function ISF_Cfg_evalItem(eval_index, eval_item, eval_flags) {
		return(ISF_EvalItem(eval_index, this.isf_cmp, eval_item, eval_flags));
	}
	// //////////////////////////////////////////////////////////////////////
}
// ////////////////////////////////////////////////////////////////////////////

// Gets a list of all of the item codes in an ISF...
// ////////////////////////////////////////////////////////////////////////////
function ISF_GetItemCodeList(isf_cfg)
{
	var eval_index = ISF_COMPILED_DATA_EVAL;
	var out_array  = new Array();
	var this_code;
	var this_prior;
	var count_1;

	for (this_prior = 0; this_prior < isf_cfg[eval_index].length; this_prior++) {
		for (this_code in isf_cfg[eval_index][this_prior])
			out_array.push(this_code);
	}

	return(out_array);
}
// ////////////////////////////////////////////////////////////////////////////

delay(1);
runGC();
delay(1);

} // if (typeof(D2JSP_INCLUDE_GUARD_ISF_d2l) == "undefined") {

// ////////////////////////////////////////////////////////////////////////////
// ////////////////////////////////////////////////////////////////////////////
//
//	Regression tests. Change the conditional to 'true' to run.
//
// ////////////////////////////////////////////////////////////////////////////
if (false) {
function main()
{
	var file_name  = "settings/ISF.cfg";
	var my_log     = new D2JSP_UTIL_Log("output/_RegressionTest.ISF.d2l.log");
	var isf_cmp    = new Array();
	var error_list = new Array();
	var pickup_list;

	print("...waiting " + (3000 / 1000) +
		" seconds for game load to complete...");
	delay(3000);

	if (!ISF_LoadConfigFromFile(file_name,
		ISF_PARSE_FLAG_CONTINUE_ON_ERROR, error_list, isf_cmp))
		print("Successfully loaded ISF configuration file '" + file_name + "'.");
	else {
		print("Errors occurred:");
		print("------ ---------");
		while (error_list.length)
			print(">>>" + error_list.shift());
		stop();
	}

	my_log.logInfo("==================== =====================================");
	my_log.logInfo("No Suffix Test:");
	my_log.logInfo("-------------------- -------------------------------------");
	my_log.logInfo("ISF File Name Basic: " + ISF_GetCfgFileNameISF());
	my_log.logInfo("ISF File Name Sell : " + ISF_GetCfgFileNameISFSell());
	my_log.logInfo("ISF File Name Shop : " + ISF_GetCfgFileNameISFShop());
	my_log.logInfo("==================== =====================================");
	my_log.logInfo("");

	my_log.logInfo("==================== =====================================");
	my_log.logInfo("With Suffix Test:");
	my_log.logInfo("-------------------- -------------------------------------");
	my_log.logInfo("ISF File Name Basic: " + ISF_GetCfgFileNameISF("TDW_PBot"));
	my_log.logInfo("ISF File Name Sell : " + ISF_GetCfgFileNameISFSell("TDW_PBot"));
	my_log.logInfo("ISF File Name Shop : " + ISF_GetCfgFileNameISFShop("TDW_PBot"));
	my_log.logInfo("==================== =====================================");
	my_log.logInfo("");

print("STOPPING");
stop();

//print("Stopping"); stop();

//	ISF_TEST_Pickup(isf_cmp);
//	ISF_TEST_Stashing(isf_cmp);
	ISF_TEST_ObjectInterface(file_name);

	my_log.closeLog();

	print("Done");
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
function ISF_TEST_Pickup(isf_cmp)
{
	var pickup_list;

/*
pickup_list = ISF_CreatePickupList(isf_cmp, ISF_PICKUP_FLAG_ALL, 40, 0, 1);
if (pickup_list.length) {
	print("ISF_PUSpec_findDrop() iterations = 100000");
	for (var count_1 = 0; count_1 < 100000; count_1++) {
		pickup_list[0].findDrop();
		if (count_1 && (!((count_1 + 1) % 10000)))
			print("Done " + (count_1 + 1) + " iterations");
	}
	print("Stopping"); stop();
}
*/

	pickup_list = ISF_CreatePickupList(isf_cmp, ISF_PICKUP_FLAG_ALL, 40,
		0, 1000);

	while (pickup_list.length) {
		print(">>> [" + pickup_list[0] + "] = " + pickup_list[0].fullNameColor);
		pickup_list.shift();
	}

	ISF_DoPickup(isf_cmp, ISF_PICKUP_FLAG_ALL, 40, 0, 1);
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
function ISF_TEST_Stashing(isf_cmp)
{
	var stash_list;

	stash_list = ISF_GetStashActionList(isf_cmp);

	while (stash_list.length) {
		print(">>> [" + stash_list[0] + "] = " + stash_list[0].fullNameColor +
			" in " + D2JSP_ITEM_CONT_ToName(stash_list[0].container) +
			" at coordinates [" + stash_list[0].x + ", " + stash_list[0].y + "].");
		stash_list.shift();
	}
//print("Stopping"); stop();

	if (ISF_DoStashing(isf_cmp))
		D2JSP_UTIL_LOG_GetALog().logError("Error in stashing occurred.");
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
function ISF_TEST_ObjectInterface(file_name)
{
//	var my_isf       = new ISF_Cfg(isf_cmp);
	var my_isf       = ISF_Create(file_name);
	var pickup_count = 0;
	var this_item;
	var this_parent;
	var this_string;

	print("My ISF object is an 'ISF_Cfg' object: " + (my_isf instanceof ISF_Cfg));
	print("My ISF configuration: " + my_isf);
	print("My ISF version: " + my_isf.getVersion());
	print("My ISF source list count: " + my_isf.getSourceList().length);
	print("My ISF spec list count: [" + my_isf.getSpecList().length + "]");
	print("My ISF code has specs for '7gr'?: [" + my_isf.getCode("7qr") + "]");
	print("My ISF first spec: [" + my_isf.getSpec(0) + "]");

	print("If every item in the game were to drop on the ground unided...");
	this_item = getUnit(D2JSP_UTIL_GETUNIT_ITEM);

	// Note: Unless your ISF configuration includes such specifications as:
	//
	//		category armor : IsRuneWord=true
	//		category weapon : IsRuneWord=true
	//
	// Any legit RuneWords (or Iths) will be reported as "wouldn't pick up'.
	//
	// Also, high-powered rares such as Corruption Grip are ignored unless
	// your configuration looks for items with those stats.
	if (this_item) {
		do {
			this_parent = this_item.getParent();
			if (this_parent && (this_parent.name == me.name) &&
				((this_item.code == "amu") || (this_item.code == "rin") ||
				(D2JSP_ITEM_ItemList[this_item.code][D2JSP_ITEM_ELEMENT_CATEGORY] !=
				"M"))) {
				if (my_isf.evalItemForPickup(this_item)) {
					this_string = "I'd pickup the " +
						(((this_item.quality < D2JSP_ITEM_QUALITY_MAGIC) ||
						this_item.getFlag(D2JSP_ITEMFLAG_IDENTIFIED)) ?
						D2JSP_ITEM_ColorItemFixFName(this_item) :
                  D2JSP_ITEM_ColorItemFullName(this_item)) + " --- ";
					if (!this_item.getFlag(D2JSP_ITEMFLAG_IDENTIFIED)) {
						if (my_isf.evalItemForId(this_item))
							this_string += "and id it to see if it's worth keeping.";
						else
							this_string += "and keep it unidentified.";
					}
					else if (this_item.quality >= D2JSP_ITEM_QUALITY_MAGIC)
						this_string += ((my_isf.evalItemForKeep(this_item)) ?
							"and keep it." : "but not keep it after identifying it.");
					else
						this_string += ((my_isf.evalItemForKeep(this_item)) ?
							"and keep it." : "but I wouldn't keep it.");
					print(this_string);
				}
				else
					print("I wouldn't pickup the " +
						D2JSP_ITEM_ColorItemFixFName(this_item) + ".");
			}
		} while (this_item && this_item.getNext());
	}
}
// ////////////////////////////////////////////////////////////////////////////

} // if (false) {


